# 迭代器模式

## 定义

迭代器模式：提供一种方法顺序访问一个集合对象中的各个元素，而又不暴露其内部的表示。

并且，遍历移动的任务是交给迭代器实现的，而不是集合本身，这样能够简化集合接口和具体实现，且也能够责任单一化。

优势：多态，即只需要该集合对象支持迭代器Iterator，那么就能通过相同的代码实现遍历。

抽象结构如下：

<img src="C:\Users\surface\AppData\Roaming\Typora\typora-user-images\image-20220317220209797.png" alt="image-20220317220209797" style="zoom:67%;" />

## eg：

需要遍历两个集合，一个是用ArrayList存储的，一个是用数组存储的

```java
public class MenuItem{			// 菜单中的具体元素
    String name;
    ...
    
    public MenuItem(String name, ...){
        ...
    }
    
    ...
}
```

菜单1：

```java
public class BreakfastMenu{ 
    ArrayList menu;
    public BreakfastMenu(){
        menu = new ArrayList<MenuItem>();
        addItem("baozi",....);
        ...
    }
    
    public void addItem(String name, ...){
        MenuItem item = new MenuItem(name, ...);
        menu.add(item);
    }
    
    public ArrayList getMenu(){
        return menu;
    }
    ....
}
```

菜单2：

```java
public class LunchMenu{
    static final int MAX_ITEMS = 6;		// 菜单最大数目
    int curNum = 0;
    MenuItem[] menu;
    public BreakfastMenu(){
        menu = new MenuItem[MAX_ITEMS];
        addItem("baozi",....);
        ....
    }
    
    public void addItem(String name, ...){
        MenuItem item = new MenuItem(name, ...);
        if(curNum > MAX_ITEMS){
            System.err.println("too much menuItem");
        }else{
            menu[curNum] = item;
            curNum++;
        }
    }
    
    public MenuItem[] getMenu(){
        return menu;
    }
    ....
}
```

如果需要遍历两个菜单，那么分别调用`getMenu()`获取两个菜单的对象，然后for循环，将集合中的项目一一列出。由于他们的内部组织结构不同，所以需要两个for循环，更多的，如果需要遍历更多的菜单，那么需要更多的for循环

问题：

1. **遍历是针对两个菜单的具体实现，而不是针对接口**
2. 如果有更多结构的菜单，eg: hashTable，那么需要修改更多的遍历代码
3. **对于遍历代码，它知道每个菜单的内部实现，违反了封装**

**改进：封装遍历**

为每个menu创建一个迭代器Iterator，来封装遍历的过程。

```java
public interface Iterator{
    public boolean hasNext();
    public Object next();
}
```

那么针对菜单2的迭代器：

```java
public class LunchMenuIterator implements Iteator{
    MenuItem[] menu;
    int position = 0;
    
    public LunchMenuIterator(MenuItem[] menu){
        this.menu = menu;
    }
    public boolean hasNext(){
        if(position >= item.length || menu[position] == null){
            return false;
        }else{
            return true;
        }
    }
    public Object next(){
        MenuItem item = menu[position];
        position++;
        return item;
    }
}

public class LunchMenu{
    static final int MAX_ITEMS = 6;		// 菜单最大数目
    int curNum = 0;
    MenuItem[] menu;
    public BreakfastMenu(){
        menu = new MenuItem[MAX_ITEMS];
        addItem("baozi",....);
        ....
    }
    
    public void addItem(String name, ...){
        MenuItem item = new MenuItem(name, ...);
        if(curNum > MAX_ITEMS){
            System.err.println("too much menuItem");
        }else{
            menu[curNum] = item;
            curNum++;
        }
    }
    
    public Iterator createIterator(){	// 将getMenu替换掉，因为getMenu会暴露内部实现——返回值就是对应实现的数据结构
        return new LunchMenuIterator(menu);
    }
    ....
}

// 使用：
BreakfastMenu bfMenu = new BreakfastMenu();
LunchMenu lMenu = new LunchMenu();
public void printMenu(){
    Iterator breakfastIterator = breakfastMenu.createIterator();
    Iterator lunchIterator = lunchMenu.createIterator();
    printMenu(breakfastIterator);
    printMenu(lunchIterator)
}
private void printMenu(Iterator iterator){		// 对外隐藏具体的集合的实现
    while(iterator.hasNext()){
        MenuItem item = iteator.next();
        ...(对item的操作)
    }
}
```

类图：

<img src="C:\Users\surface\AppData\Roaming\Typora\typora-user-images\image-20220317211728236.png" alt="image-20220317211728236" style="zoom:67%;" />

——实际上，Java SDK提供了Collection类型的Iteator迭代器，所以ArrayList可以直接使用，而数组需要继承java.util.Iterator，然后实现里面的方法

（省略LunchIterator继承java.util.Iterator实现的代码，就是加上了一个remove()操作）

再稍微封装一下：

```java
public interface Menu{
    public Iterator createIterator();
}
```

<img src="C:\Users\surface\AppData\Roaming\Typora\typora-user-images\image-20220317215756206.png" alt="image-20220317215756206" style="zoom:67%;" />

更进一步：如果有很多份菜单需要遍历，那么可以创建一个Menu的ArrayList，利用Iterator去获取每一个menu，然后menu里面调用iterator去遍历：

```java
public class Waitress{
    ArrayList menus;
    public Waitress(ArrayList menus){
        this.menus = menus;
    }
    
    public void printMenu(){
        Iterator iterator = menus.iterator();
        while(iterator.hasNext()){
            Menu menu = (Menu)iterator.next();
            printMenu(menu.createIterator());
        }
    }
    public printMenu(Iterator iterator){
        while(iterator.hasNext()){
            MenuItem item = (MenuItem)iterator.next();
            ...
        }
    }
}
```

## 设计原则

单一责任：一个类应该只有一个引起变化的原因。如果有多个责任，就会出现多个可改变的区域。

又被称为内聚，当一个模块或者一个类只支持一组相关的功能时，就是高内聚。被设计成支持一组不相关的功能时，就是低内聚。



但是如果出现，部分菜单的item还是菜单的问题

<img src="C:\Users\surface\AppData\Roaming\Typora\typora-user-images\image-20220317224556747.png" alt="image-20220317224556747" style="zoom:67%;" />

可以看出，构成了一棵树：

<img src="C:\Users\surface\AppData\Roaming\Typora\typora-user-images\image-20220317224643295.png" alt="image-20220317224643295" style="zoom:80%;" />

——使用组合模式：

# 组合模式

## 定义

组合模式：将对象组合成树性结构来表现“整体/部分”的层次结构，组合能够让客户**以一致的方式处理**个别对象和对象组合。

每一个菜单就是组合；每一个菜单项就是一个个别对象，就是叶子节点

——反正就是存在“整体和部分”的关系，然后需要用一致的方法处理时，可以用组合模式（私以为）

组合模式的类图：

<img src="C:\Users\surface\AppData\Roaming\Typora\typora-user-images\image-20220319143411873.png" alt="image-20220319143411873" style="zoom:67%;" />

所有对象都继承一个component类，在实现的时候，叶子节点因为没有孩子，所以实现部分方法；非叶子结点由于有孩子，实现需要的部分方法。

## eg：

菜单（包含子菜单的）

<img src="C:\Users\surface\AppData\Roaming\Typora\typora-user-images\image-20220319144021245.png" alt="image-20220319144021245" style="zoom:70%;" />

具体实现：

抽象父类

```java
public abstract class MenuComponent{
    // 菜单特有的方法
    public void add(MenuComponent component){
        throw new UnsupportedOperationException();		// 默认实现是不支持该搞错
    }
    public void remove(MenuComponent component){
        throw new UnsupportedOperationException();
    }
    public MenuComponent getChild(int i){
        throw new UnsupportedOperationException();
    }
    
    // 菜单项可以用，菜单也可以用
    public String getName(){
        throw new UnsupportedOperationException();
    }
    public String getDescription(){
        throw new UnsupportedOperationException();
    }
    public void print(){
        throw new UnsupportedOperationException();
    }
    
    // 菜单项可以用
    public double getPrice(){
        throw new UnsupportedOperationException();
    }
    public boolean isVegetarian(){
        throw new UnsupportedOperationException();
    }
    
}
```

菜单项实现：

```java
public class MenuItem extends MenuCompnent{
    private String name;
    private String description;
    private boolean vegetarian;
    private double price;
    
    public MenuItem(...){
        ...
    }
    public String getName(){
        return name;
    }
    public String getDescription(){
        return description;
    }
    public double getPrice(){
        return price;
    }
    public boolean isVegetarian(){
        return vegetarian;
    }
    public void print(){
        System.out.print(getName());
        if(isVegetarian()){
            System.out.print("v");
        }
        System.out.print(getPrice());
        System.out.print(getDescription());
    }
}
```

菜单实现：

```java
public class Menu extends MenuCompnent{
    private ArrayList menu = ArrayList<MenuItem>();
    private String name;
    private String description;
    
    public Menu(...){
        ...
    }
    public String getName(){
        return name;
    }
    public String getDescription(){
        return description;
    }
    public void add(MenuComponent component){
        menu.add(component);		
    }
    public void remove(MenuComponent component){
        menu.remove(compnent);
    }
    public MenuComponent getChild(int i){
        return (MenuComponent)menu.get(i);
    }
    public void print(){
        System.out.print(getName());
        System.out.print(getDescription());
        System.out.print("----------------");
        Iteator iterator = menu.iterator();
        while(iterator.hasNext()){				// 遍历菜单中的菜单项和菜单
            MenuComponent menuComponent = (MenuComponent)iterator.next();
        }
    }
}
```

使用：

```java
public class Waiter{
    MenuComponent allMenus;
    public Waiter(MenuComponent allMenus){
        this.allMenus = allMenus;
    }
    public void printMenus(){
        allMenus.print();			// 会出现递归打印——树状结构
    }
}
```

存在一个问题：**组合模式牺牲了单一责任的设计原则**。因为对于菜单类，既需要管理层次结构，又需要执行菜单的操作，例如添加、删除等——组合模式用单一责任换取了透明性，即通过接口来统一管理叶子结点和非叶子结点，且由于继承了统一接口，那么会失去一些安全性

## 外部迭代器

<img src="C:\Users\surface\AppData\Roaming\Typora\typora-user-images\image-20220321160749790.png" alt="image-20220321160749790" style="zoom:67%;" />

```java
public class Menu extends MenuComponent{
    ...
    public Iterator createIterator(){
        return new CompositeIteator(menu.iterator());
    }
}

public class MenuItem extends MenuComponent{
    ...
    public Iteator createIterator(){
        return new NullIterator();
    }
}
```

递归迭代器

```java
public class CompositeIteator extends Iterator{
    Stack stack = new Stack<Iteator>();
    
    public CompositeIteator(Iterator iterator){
        stack.push(iterator);			// 将当前的（顶层）迭代器加入到堆栈底部
    }
    
    public boolean hasNext(){
        if(stack.empty()){			// 堆栈为空，说明已经全部遍历完了
            return false;
        }
        else{				// 栈不为空
            Iterator iterator = (Iterator)stack.peek();		// 查看栈顶元素
            if(!iterator.hasNext()){			// 如果栈顶的迭代器没有元素要遍历了	
                stack.pop();			// 弹出栈顶
                return hasNext();			// 递归再去查栈和栈顶元素
            }else{
                return true;		// 存在next的迭代器还是在栈顶的
            }
        }
    }
    public Object next(){
        if(hasNext()){
            Iterator iterator = (Iterator)stack.peek();
            MenuComponent menuComponent = (MenuComponent)iterator.next();
            if(menuComponent instanceof Menu){
                stack.push(menuComponent.createIterator());
            }
        }else{
            return null;
        }
    }
    public void remove(MenuComponent component){
        throw new UnsupportedOperationException();
    }
}
```

```java
public class NullIterator implements Iterator{
    public Object next(){
        return null;
    }
    public boolean hasNext(){
        return false;
    }
    public void remove(MenuComponent component){
        throw new UnsupportedOperationException();
    }
}
```

