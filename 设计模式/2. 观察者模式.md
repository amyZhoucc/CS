# 观察者模式

## 定义

观察者模式：定义了对象之间的一对多依赖，当对象改变状态时，它所有的依赖者都能收到通知并自动更新

<img src="pic\image-20220324140810906.png" alt="image-20220324140810906" style="zoom:57%;" />

观察者模式：观察者（Observer）和主体（Subject）

观察者订阅（注册，subscribe）该主题，该主题发生变化时，会通知观察者变化的情况。取消订阅之后就再也收不到了

优势：对象之间实现了松耦合，可以交互，但是不需要知道细节

1. subject知道观察者实现了接口Observer，但是不需要知道观察者的作用、是谁等具体细节
2. 任何时候都可以增加、删除、替换Observer。因为主题唯一依赖时一个实现Observer接口的对象列表
3. 两者各自变化，都不会影响另外一方的代码
4. 可以独立的复用主题或观察者

## 设计原则4

为了交互对象之间的松耦合设计而努力

## eg

天气监测，需要根据装置通过WeatherData去获取当前的温湿度气压，并且更新三个布告板的信息

<img src="pic\image-20220324134047484.png" alt="image-20220324134047484" style="zoom:50%;" />

WeatherData现有的方法

```java
public class WeatherData{
	public double getTempature(){
        ...
    }
    public double getHumdity(){
        ...
    }
    public double getPressure(){
        ...
    }
    public void measurementsChanged(){		// 有新的测量值，就马上更新布告栏
        ...
    }
}
```

实现方法1：

```java
public void measurementsChanged(){		
    double temp = getTempature();
    double humid = getHumdity();
    double press = getPressure();
    curConditionDisplay.update(temp, humid, press);
    ....// 其他两个布告栏的信息
}
```

问题：

1. 针对具体的编程，而不是接口
2. 无法动态增加新的、删除旧的布告栏，一旦这样必须要修改代码
3. 改变的部分没有被封装起来——布告栏就是变化的部分，没有被封装

根据观察者模式来设计：

<img src="pic\image-20220324142952542.png" alt="image-20220324142952542" style="zoom:67%;" />

实现：

接口：

```java
public interface Subject{
    public void registerObserver(Observer o);
    public void removeObserver(Observer o);
    public void notifyObservers();				// 主题发生变化，主动通知所有观察者
}

public interface Observer{
    public void update(float temp, float humid, float press);		// 主题变化，会调用观察者的update方法去更新数据
}

public interface DisplayElement{			// 布告板显示接口
    public void display();				
}
```

主题：

```java
public class WeatherData implements Subject{
    private ArrayList observers;		// 存储所有的订阅者
    private double temperature;
    private double humidity;
    private double pressure;
    public WeatherData(){
        observers = ArrayList<Observer>();
    }
    public void registerObserver(Observer o){
        observers.add(o);
    }
    public void removeObserver(Observer o){
        observers.remove(o);
    }
    // 较为关键的点
    public void notifyObservers(){
        for(int i = 0; i < observers.size(); i++){
            Observer o = (Observer)observers.get(i);
            o.update(temperature, humidity, pressure);	// 调用订阅者的update方法（必然有的方法），其他不关注
        }
    }
    
    public void measurementsChanged(){
        notifyObservers();
    }
    public void setMeasurements(double temp, double humid, double press){
        temperature = temp;
        humidity = humid;
        pressure = press;
        measurementsChanged();
    }
}
```

观察者：

```java
public class CurConditionDisplay implements Observer, DisplayElement{
    private double temperature;
    private double humidity;
    private Subject weatherData;		// 维护一个主题对象的实例变量
    
    public CurConditionDisplay(Subject weatherData){
        this.weatherData = weatherData;
        weatherData.registerObserver(this);			// 注册——唯一的交互
    }
    public void update(float temp, float humid, float press){
        this.temperature = temp;
        this.humidity = humid;
        display();
    }
    public void display(){
        ....
    }
}
```

使用：

```java
public class WeatherStation{
    public static void main(String[] args){
        WeatherData weatherData = new WeatherData();		// 创建主题
        
        CurConditionDisplay curDisplay = new CurConditionDisplay(weatherData);	// 订阅者，并订阅
        StatisticsDisplay statisticDisplay = new StatisticsDisplay(weatherData);
        ...		// 其他订阅者
        
        weatherData.setMeasurements(80, 64, 30.5);		// 类似于传感器
        
    }
}
```

这个的实现思路是：**主题主动推指定的数据给观察者；也有观察者主动拉主题中需要的数据**

——我理解的推拉的含义：

1. **推，是指主题将能公开的数据全部推给所有观察者，而不管观察者是否需要这些数据**
2. **拉，是指主题不指定数据，由观察者在update方法中根据subject去获取需要的数据**

## eg2

Java API内置观察者模式

<img src="pic\image-20220324152834047.png" alt="image-20220324152834047" style="zoom:70%;" />

解释：

1. Observable是一个类，而不是接口，是可观察者（主题）
2. Observer是订阅者，同上

主题发送通知：

1. `setChanged()`调用，标记该主题状态变化的事实
2. `notifyObservers()/notifyObservers(Object arg)`前者是拉数据，后者是推数据，可以指定通知的数据

观察者接受：

1. `update(Observable o, Object obj)`，需要明确是哪个主题通知的，notifyObservers中的参数，没有可以为null

注意：主题发送通知，需要2步：

```java
setChanged(){
	changed = true;
}

notifyObservers(){
    if(changed){
        for...
    }else{
        changed = false;
    }
}
```

——这样的好处：在更新观察者有更多的弹性，例如：气象站的温度很敏锐，会产生持续不断的更新，而setChanged，可以让**用户自行设定更新的灵敏度**