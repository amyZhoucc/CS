# 策略模式

## 定义

策略模式：定义了算法族，分别封装起来，让他们之间（算法族内部）可以互相替换。此模式，能够让算法的变化独立于使用算法的客户。

## 设计原则1

找出应用中可能需要变化的地方，将他们独立出来，不要和不需要变化的代码混在一起——变化的部分进行单独封装，其他部分不会受到影响，变化部分可以随便改和扩充了。

## 设计原则2

针对接口（超类型，可以是抽象类/接口）编程，而不是针对实现编程。

针对实现：

```java
Dog animal = new Dog();
animal.makeSound();
```

针对接口

```java
Animal animal = new Dog();
animal.makeSound();			// 这个在执行时就会利用多态，去定位dog这个具体类中的实现

// 更进一步的，在方法中获取动物类，而不需要知道具体是何种动物
Animal a = getAnimal();
a.makeSound();
```

## 设计原则3

多用组合，少用继承

## eg

设计鸭子类

初始时是简单的鸭子类

<img src="C:\Users\surface\AppData\Roaming\Typora\typora-user-images\image-20220324124623224.png" alt="image-20220324124623224" style="zoom:50%;" />

后面扩展功能，鸭子会飞

<img src="C:\Users\surface\AppData\Roaming\Typora\typora-user-images\image-20220324124752472.png" alt="image-20220324124752472" style="zoom:67%;" />

如果直接在超类上面增加fly方法，那么对于一些不会飞的鸭子就会出现麻烦，例如RubberDuck

——方法：RubberDuck覆盖父类的fly方法，啥事都不做——不是一个好方法

问题：如果功能进一步扩展，就需要不断的修改子类中的代码

方法2：使用接口

<img src="C:\Users\surface\AppData\Roaming\Typora\typora-user-images\image-20220324125302900.png" alt="image-20220324125302900" style="zoom:50%;" />

问题：重复代码会大量增加，本来会飞的鸭子只需要相同的代码即可，现在需要全部子类中自行实现

所以：

1. 继承：改变会牵一发而动全身，带来其他子类不想要的改变；并且扩展性差，一旦修改父类，有可能有很多子类需要相应的改变
2. 接口：复用性差。

所以按照策略模式和设计原则来，

1. 我们将鸭子类的的fly相关和quack相关分离出来

2. **单独组件两组类，实现飞行的相关动作和叫的相关动作**

   <img src="C:\Users\surface\AppData\Roaming\Typora\typora-user-images\image-20220324130920415.png" alt="image-20220324130920415" style="zoom:50%;" />

3. 每个接口代表每个行为，行为的每个实现都是去实现对应的类——这就是行为类

   它的核心就是利用多态，执行时就会对应绑定。

   <img src="C:\Users\surface\AppData\Roaming\Typora\typora-user-images\image-20220324130940800.png" alt="image-20220324130940800" style="zoom:67%;" />

   ——之后：**鸭子将飞行和叫都委托给行为类去处理，而不会在自己内部进行定义**

   类结构如下：

   <img src="C:\Users\surface\AppData\Roaming\Typora\typora-user-images\image-20220324131724932.png" alt="image-20220324131724932" style="zoom:57%;" />

   ```java
   public class Duck{
       FlyBehavior flyBehavior;
       ...
       
       public void performFly(){
           flyBehavior.fly();
       }
       
       // 可以随时调用，改变鸭子的可变行为
       public void setFlyBehavior(FlyBehavior flyBehavior){
           this.flyBehavior = flyBehavior;
       }
       .....
   }
   
   public class MallardDuck extends Duck{
       public MallardDuck(){
           this.flyBehavior = new FlyWithWings();
           this.quackBehavior = new Quack();
       }
       ....
   }
   ```

   行为类：举例

   ```java
   public interface FlyBehavior{
       public void fly();
   }
   
   public FlyWithWings implements FlyBehavior{
       public void fly(){
           System.out,println("i can fly with wings");
       }
   }
   
   public FlyNoWay implements FlyBehavior{
       public void fly(){
           System.out.println("i can't fly");
       }
   }
   ```

   

