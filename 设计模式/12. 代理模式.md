# 代理模式

在多个设备之间，这些设备不在同一个JVM堆栈上面运行，他们中间通过代理进行辅助，由于对用户解耦，让用户以为是直接跟服务端进行沟通的

## 定义

**代理模式：为一个对象提供替身或者占位符以控制这个对象的访问**。即创建代表对象，让代表对象取控制对某个对象的访问。

某个对象可以是远程对象、开销大的资源、需要安全控制的对象

1. 远程代理
2. 虚拟代理：控制访问创建开销大的资源
3. 安全代理：进行权限控制访问资源
4. 防火墙代理
5. 智能引用代理
6. 缓存代理
7. 同步代理
8. 复杂隐藏代理
9. 写入时复制代理

类图：

<img src="pic\image-20220326151031443.png" alt="image-20220326151031443" style="zoom:67%;" />

1. RealSubject是真正做事的对象，例如远程的服务器，被保护的对象等
2. proxy就是代理，有时候还负责RealSubject对象的创建与销毁（虚拟代理时，需要才创建）
3. Subject是超类，能够保证在需要RealSubject的地方都能由proxy替换，从而实现良好的隔离

## eg：远程代理

<img src="pic\image-20220325192419758.png" alt="image-20220325192419758" style="zoom:67%;" />

提供一些辅助对象：

1. 客户调用客户辅助对象的方法，以为辅助对象就是服务对象本身
2. 服务对象由服务辅助对象调用，让服务对象以为调用来自本地（服务辅助对象）

## Java RMI

JavaRMI（remote method invocation）java 远程方法调用的库，能够实现对远程代理

原理如下：

<img src="pic\image-20220325194337040.png" alt="image-20220325194337040" style="zoom:67%;" />

### 使用

1. **制作远程接口**：只需要继承接口Remote，即表示来支持远程调用

   ```java
   import java.rmi.*;
   public interface MyRemote extends Remote{
       public String sayHello() throws RemoteException;	// 所有方法都有可能抛出异常，因为涉及网络请求
   }
   ```

   注意：接口里定义的方法的返回值必须要属于原语或者可序列化类型，因为通过网络运送时需要靠序列化完成。所以如果使用的是Java内置的，例如原语类型、字符串、API内定的类型（数组、集合等）都是可以被序列化的，而自定义的类型必须要保证实现了Serializable接口

2. **制作远程实现**：对上面接口的实现，就是客户端需要调用的方法接口

   ```java
   public class MyRemoteImpl extends UnicastRemoteObject implements MyRemote{
       public MyRemoteImpl() throws RemoteException{}		// 因为超类构造器抛出异常，所以子类也需要抛出
       public String sayHello(){			// 不需要声明异常了
           return "hello";
       }
       public static void main(String[] args){
           try{
               MyRemote service = new MyRemoteImpl();		// 1. 服务实例化
               Naming.rebind("RemoteHello", service);		// 2. 绑定到RMI的registry，这样客户端就能找到它
           }catch(Exception e){
               e.printStackTrace();
           }
       }
   }
   ```

   注意：继承的是`UnicastRemoteObject`，是为了实现**远程的功能**

   注意在注册的时候，要**确保`RMI Registry`正在运行**，否则注册代码会执行失败

3. 利用rmic产生的stub和skeleton（客户辅助对象和服务端辅助对象）

   远程实现类上执行rmic，就是在该类的当前目录下，运行`rmic MyRemoteImpl `，就会产生两个对应的新类`MyRemoteImpl_Stub.class`和`MyRemoteImpl_Skel.class`

4. 启动rmi registry注册

   开启一个终端，运行`rmiregistry`（该终端要能访问到服务类，所以在类目录下启动为好）

5. 开始远程服务

   开启另外一个终端，启动服务（该服务是从MyRemoteImpl的main函数开始执行的）

客户端获取stub对象，通过`RMI Registry`

```java
MyRemote service = (MyRemote)Naming.lookup("rmi://127.0.0.1/RemoteHello");
```

1. 接受的类型是服务器的接口类型即可
2. 通过**静态方法`Naming.lookup(...)`**，需要指出服务器的运行位置的主机名和ip地址，以及在注册时用的名字RemoteHello（能找到对应的类）
3. 客户端需要有stub类才能使用——可以让服务端直接移交给它（因为stub就是在服务端由RMI产生的）

原理：

<img src="pic\image-20220326150129735.png" alt="image-20220326150129735" style="zoom:50%;" />

至此获取的stub，客户端可以随意调用，就像调用真正的服务器对象一样

客户端代码

```java
import java.rmi.*;
public class MyRemoteClient{
    public static void main(String[] args){
        new MyRemoteClient().communicate();
    }
    public void communicate(){
        try{
            MyRemote service = (MyRemote)Naming.lookup("rmi://127.0.0.1/RemoteHello");
            String s = service.sayHello();		// 跟直接调用服务器表面看起来一样
        }catch(Exception e){
            e.printStackTrace()
        }
    }
}
```

## eg2：虚拟代理

web请求加载一张图片，但是图片加载较为缓慢，在加载出来之前需要有显示东西，当加载完成之后，就显示具体的图片

——**虚拟代理：直到真正需要一个对象的时候才创建它，在对象被创建前或者创建时，都由虚拟代理来扮演该对象来处理请求，对象创建完成之后，代理将请求直接委托给对象**

<img src="pic\image-20220326161524676.png" alt="image-20220326161524676" style="zoom:67%;" />

类图：

<img src="pic\image-20220326161646667.png" alt="image-20220326161646667" style="zoom:67%;" />

虚拟代理ImageProxy的作用：

1. 首先它负责创建ImageIcon对象，然后发起网络请求去加载图片
2. 在加载时，ImageProxy会显示一段话”图片加载中....“
3. 当图片加载完毕，ImageProxy会将请求的方法委托给ImageIcon去执行，包括`paintIcon()，getIconWidth(), getIconHeight()`

```java
class ImageProxy implements Icon{
    ImageIcon imageIcon;		// 真正的图像对象
    URL imageUrl;
    Thread retrievalThread;
    boolean retrieval;			// 判断是否发起网络请求
    
    public ImageProxy(URL url){
        imageUrl = url;
    }
    public int getIconWidth(){
        if(imageIcon == null){
            return 800;
        }else{
            return imageIcon.getIconWidth();		// 加载完成就交给真正对象处理
        }
    }
    public int getIconHeight(){
        if(imageIcon == null){
            return 600;
        }else{
            return imageIcon.getIconHeight();
        }
    }
    public void paintIcon(){
        if(imageIcon != null){
            imageIcon.paintIcon();
        }else{
            show();			// 显示备用图片
            if(!retrieval){			// 尚未发起过请求图片
                retrieval = true;
                retrievalThread = new Thread(new Runnable(){	// 单独创建一个线程去请求，防止阻塞当前线程
                    public void run(){
                        try{
                            imageIcon = new ImageIcon(imageUrl, "Image");	// 代理去创建开销大的资源
                            c.repaint();		// 到这一步，说明线程已经加载完成图片，那么重新绘制页面，paintIcon会重新调用
                        }catch(Exception e){
                            e.printStackTrace();
                        }
                    }
                });
                retrievalThread.start();
            }
        }
    }  
}
```

## eg3：安全代理

对一个数据库数据，有些用户需要能够有查看权限，有些需要能够修改权限

Java API能提供一个**动态代理**，可以在运行时动态地创建一个代理类，实现一个或者多个接口，并将方法调用转发到指定的类。

<img src="pic\image-20220326191445203.png" alt="image-20220326191445203" style="zoom:67%;" />

例如：有一个人口相关信息的数据库，对于用户来说不能改变自己的数据，也不能改变其他用户的个人信息

1. 创建2个InvocationHandler

   2个调用处理器，一个给拥有者使用，另一个给非拥有者使用。

   当proxy的方法被调用时，proxy会把这个调用转发给InvocationHandler，而InvocationHandler被调用的一定是invoke方法

   eg：proxy的`setHotOrNotRating()`，那么proxy会调用InvocationHandler的`invoke(Object proxy, Method method, Object[] obj)`，将对应的方法和参数传递进去。InvocationHandler会决定如何处理这个请求，是否将其转给RealSubject解决（看权限）

   ```java
   import java.lang.reflect.*;
   public class OwnerInvocationHandler implements InvocationHandler {
       Person person;		// 真实主题
       public OwnerInvocationHandler(Person person){
           this.person = person;
       }
       public Object invoke(Object proxy, Method method, Object[] obj) throws IllegalAccessException{
           try{
               if(method.getName.startWith("get")){		// 允许访问操作
                   return method.invoke(person, args);
               }else if(method.getName.equals("setHotOrNotRating")){		// 禁止设置操作
                   throw new IllegalAccessException()
               }else{
                   return method.invoke(person, args);
               }
           }catch(Exception e){
               e.printStackTrace();
           }
       }
   }
   ```

2. 写代码创建动态代理proxy

   ```java
   Person getOwnerProxy(Person person){
       return (Person)Proxy.newProxyInstance(
       		person.getClass().getClassLoader(),
           	person.getClass().getInterfaces(),
           	new OwnerInvocationHandler(person));
   }
   ```

3. 利用适当的代理包装任何Person对象

   ```java
   Person joe = new Person("joe");
   Person ownerProxy = getOwnerProxy("joe");
   ownerProxy.getName();			// 应该是能成功地
   ownerProxy.setHotOrNotRating("10");			// 修改失败
   ownerProxy.setName("judy");		// 修改成功
   ```

   



