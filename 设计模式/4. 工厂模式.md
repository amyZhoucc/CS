# 工厂模式

与创建对象相关

## 定义

**工厂模式：定义了一个创建对象的接口，由子类决定要实例化的类是哪个，工厂方法将类的实例化推迟到了子类。**

——让子类决定该创建的对象是什么，来达到new对象过程的封装

<img src="pic\image-20220324233602047.png" alt="image-20220324233602047" style="zoom:67%;" />

注意：

1. **创建者父类有操作产品的方法，但是不实现工厂方法，即不负责创建产品对象**
2. 创建者具体类必须要**实现父类提供抽象的工厂方法**，该工厂方法中会去**决定具体调用哪个产品类去实例化对象**
3. 产品具体类都是继承自产品父类，从而能在创建者类中统一赋值给接口类型变量

具体的：

<img src="pic\image-20220324233231171.png" alt="image-20220324233231171" style="zoom:67%;" />

产品类（实际创建的对象）和创建者类（发起请求的类）之间是平行关系

**抽象工厂模式：提供一个接口，用于创建相关或依赖的对象家族，而不需要明确指定具体类**。抽象接口可以来创建一组产品，但是不需要关注具体的产品是什么，它创建的是一个产品家族（是对象的组合）

<img src="pic\image-20220325132816177.png" alt="image-20220325132816177" style="zoom:67%;" />

具体的例子：

<img src="pic\image-20220325132939340.png" alt="image-20220325132939340" style="zoom:67%;" />

工厂模式和抽象工厂模式比较：

1. 工厂模式用来创建一类产品；抽象工厂模式是用来创建产品家族，有多类产品
2. 工厂模式主要是利用了继承，具体工厂类来创建具体产品对象；抽象工厂模式是利用组合，将产品家族组合起来，问题是：加入新类型的产品就要增加抽象工厂接口和具体工厂两部分的代码

## 设计原则6

依赖倒置原则：**要依赖抽象，不要依赖具体类**。

理解，与要针对接口编程，而不是实现编程的区别：

1. 依赖倒置：**不能让高层组件依赖低层组件，且高低层组件都应该依赖于抽象，而不是具体**

   eg：PizzaStore是高层组件，Pizza是低层组件，在第一版中PizzaStore是依赖具体的Pizza类的；后面运用工厂方法高层组件依赖的是抽象

   <img src="pic\image-20220325104436020.png" alt="image-20220325104436020" style="zoom:50%;" />

   依赖倒置原则遵循：

   1. **变量不可以持有具体类的引用**：直接使用new，就会持有具体类，可以用工厂方法替换创建对象
   2. **不要让类派生自具体类**：派生自具体类就会依赖具体类，改用派生自抽象
   3. **不要覆盖基类中已经实现的方法**：如果基类的方法被覆盖，那么基类不是一个合适的被继承的抽象
   
   不要教条化，内化尽量满足即可

## eg

披萨商店制作披萨，有许多pizza类型

初始：点pizza的方法

```java
Pizza orderPizza(String type){
    Pizza pizza;
    if(type == "cheese"){
        pizza = new CheesePizza();
    }else if(type == "onion"){
        pizza = new OnionPizza();
    }...		// 有多个pizza类型可以选择
        
    // pizza的一系列制作过程
    pizza.prepare();
    pizza.bake();
    pizza.cut();
    pizza.box();
    return pizza;
}
```

（里面的pizza都是继承自Pizza超类）

问题：该代码没有对修改封闭——一旦增加新的pizza种类，就要修改if...else的代码

——将变化的部分独立出来，创建一个**pizza工厂**

```java
public class PizzaFactory{
    public Pizza createPizza(String type){
        Pizza pizza = null;
        if(type == "cheese"){
            pizza = new CheesePizza();
        }else if(type == "onion"){
            pizza = new OnionPizza();
        }...		// 有多个pizza类型可以选择
        
        return pizza;
    }
}

// 使用
public class PizzaStore{
    PizzaFactory factory;
    public PizzaStore(PizzaFactory factory){
        this.factory = factory;
    }
    public Pizza orderPizza(String type){
        Pizza pizza = factory.createPizza(type);

        // pizza的一系列制作过程
        pizza.prepare();
        pizza.bake();
        pizza.cut();
        pizza.box();
        return pizza;
    }
}
```

进一步，出现了pizza加盟店，不同地方的pizza有不同的风味，例如纽约pizza，芝加哥pizza。

<img src="pic\image-20220324201225852.png" alt="image-20220324201225852" style="zoom:67%;" />

```java
public abstract class PizzaStore{
    public Pizza orderPizza(String type){
        Pizza pizza = createPizza(type);

        pizza.prepare();
        pizza.bake();
        pizza.cut();
        pizza.box();
        return pizza;
    }
    abstract Pizza createPizza(String type);			// 抽象方法
}

// 具体的实现类，特定地区的pizza商店
public class NYStylePizzaStore extends PizzaStore{
    public Pizza orderPizza(String type){
        Pizza pizza = null;
        if(type == "cheese"){
            pizza = new NYStyleCheesePizza();		// 创建具体的pizza，制作pizza在父类中的orderPizza已经实现了
        }else if(type == "onion"){
            pizza = new NYStyleOnionPizza();
        }...		// 有多个pizza类型可以选择
        
        return pizza;
    }
}

// 使用
public class Client{
    public static void main(String[] args){
        PizzaStore NYPizzaStore = new NYStylePizzaStore();		// 先获取需要的pizza商店
        PizzaStore ChicagoPizzaStore = new ChicagoStylePizzaStore();	
        Pizza pizza = NYPizzaStore.orderPizza("cheese");
        Pizza pizza2 = ChicagoPizzaStore.orderPizza("onion");
    }
}
```

`abstract Pizza createPizza(String type);`就是一个工厂方法

——更形式化的：

**`abstract Product factoryMethod(String type)`**

1. 工厂方法是**抽象**的，依赖子类的实现来**生产具体的对象**
2. 工厂方法必须返回一个产品对象，在超类中的方法需要用到该产品
3. 工厂方法将客户（使用产品的代码，eg：`orderPizza()`）和实际创建具体产品的代码分离

pizza类型：

<img src="pic\image-20220324233037151.png" alt="image-20220324233037151" style="zoom:50%;" />

```java
public abstract class Pizza{
    String name;
    String dough;		// 面团
    String sauce;		// 酱料
    ArrayList topping = new ArrayList<>();
    
    void prepare(){
        // 一些准备工作，备菜，加酱料，加佐料
    }
    
    void bake(){...}
    void cut(){...}
    void box(){...}
}

// 具体子类
public class NYStyleCheesePizza extends Pizza{
    public NYStyleCheesePizza(){
        name = "...";
        dough = "...";
        sauce = "...";
        topping.add("...");
    }
    void cut(){
        // 有自定义的切片方式
    }
}
```

## eg2

在上面已经实现了客户指定pizzaStore之后，根据需要制定不同风格的pizza，就会调用工厂方法去创建pizza。已经有的是不同pizza加盟店，NY、Chicago等，现在想要**创建原料工厂，由工厂统一配送原料到加盟店**，不同地区的加盟店的原材料不同，所以需要对应地区创建不同的原料工厂

要求：不同地区都有不同的原料工厂；原料工厂要包括：面团、酱料、芝士、蔬菜、海鲜等确定种类的组件。（pizza工厂根据对应的pizza制作需要，选择几种原料制作）

原料工厂抽象类——**抽象工厂（和上面的工厂不同，这个工厂是抽象的）**

```java
public interface PizzaIngredientFactory{
    public Dough createDough();
    public Sauce createSauce();
    public Cheese createCheese();
    public Veggies[] createVeggies();
    public Clams createClam();
}
```

具体原料工厂类：——实际工厂

```java
public class NYPizzaIngredientFactory implements PizzaIngredientFactory{
    public Dough createDough(){
        return new ThinCrustDough();
    }
    public Sauce createSauce(){
        return new MarinaraSauce();
    }
    public Cheese createCheese(){
        return new ReggianoCheese();
    }
    public Veggies[] createVeggies(){
        Veggies[] veggies = { new Gralic(), new Onion(), new Mushroom()};
        return veggies;
    }
    public Clams createClam(){
        return new FreshClams();
    }
}
```

那么对应的pizza的原材料准备的方法也需要修改

```java
public abstract class Pizza{
    String name;
    String dough;		// 面团
    String sauce;		// 酱料
    String cheese;
    Veggies[] veggies;
    Clam clam;
    
    abstract void prepare();		// 将准备材料的方法变成抽象方法
    
    void bake(){...}
    void cut(){...}
    void box(){...}
}
```

如果芝士pizza的做法都一样，就原材料不一样，则可以用同一个ChessePizza，只需要指定不同的原材料工厂即可：

```java
public class CheesePizza{
    PizzaIngredientFactory ingredientfactory;		// 只需要指定不同的原材料工厂，就可以获得不同的原材料
    public CheesePizza(PizzaIngredientFactory ingredientfactory){
        this.ingredientfactory = ingredientfactory;
    }
    void prepare(){
        ingredientfactory.createDough();
        ingredientfactory.createSauce();
        ingredientfactory.createCheese();
    }
}
```

pizzaStore稍微有所修改：

```java
public class NYStylePizzaStore extends PizzaStore{
    public Pizza orderPizza(String type){
        Pizza pizza = null;
        PizzaIngredientFactory ingredientfactory = new NYPizzaIngredientFactory();	// 指定原料工厂
        if(type == "cheese"){
            pizza = new CheesePizza(ingredientfactory);		
        }else if(type == "onion"){
            pizza = new OnionPizza(ingredientfactory);
        }...		// 有多个pizza类型可以选择
        
        return pizza;
    }
}

```

