# 桥接模式

> 将抽象部分和实现部分分离，通过组合的方式，使他们都可以独立变化，从而避免状态爆炸
>
> 理解抽象和实现：
>
> 1. 抽象：不是接口、抽象类，而是一套类库，抽象是只有骨架代码，真正的业务逻辑是交给“实现”完成的
>
> 2. 实现：不是一个简单的实现类，而是一整套类库
>
>    eg：
>
>    <img src="pic\image-20220510193646202.png" alt="image-20220510193646202" style="zoom:60%;" />

类图：

<img src="pic\image-20220510165254049.png" alt="image-20220510165254049" style="zoom:67%;" />

抽象角色：抽象定义，会持有一个“实现角色”的引用——这个就是桥

扩展抽象角色：继承父类Abstraction，并对父类的方法进行扩展（改变、修正）

抽象实现角色：实现类的接口，但是并不给出实现

具体实现角色：继承自Implementor，对父类进行实现

eg：

两个维度：

1. 车——对应车的具体类，比如说五菱宏光、大奔——M类
2. 挡位类型——对应挡位的具体类，比如说自动挡、手动挡、手自一体——N类

如果用继承，则有M*N个具体类

如果用组合，那么只需要M(N)类

应用场景：

1. 一个类存在两个独立变化的维度，并且这两个维度都需要扩展

优势：

1. 扩展性强
2. 抽象和实现分离

## eg:

```java
// 抽象角色
public abstract class Notification{
    protected MsgSender msgSender;		//  持有抽象实现角色的引用
    
    public Notification(MsgSender msgSender){
        this.msgSender = msgSender;
    }
    public abstract void notify(String message);
}

// 扩展抽象角色
public class ServerNotification extends{
    public Notification(MsgSender msgSender){
        super(msgSender);
    }
    @Overrride
    public void notify(String message){
        msgSender.send(message);
    }
    ....			// 一些自定义的方法
}

// 抽象实现角色（即上面持有引用的对象）
public interface MsgSender{
    void send(String message);
}
// 具体实现角色
public class TelephoneMsgSender implements MsgSender{
    private List<String> phoneNumbers;
    public TelephoneMsgSender(List<String> phoneNumbers){
        this.phoneNumbers = phoneNumbers
    }
    @Override
    public void send(String message){
        ....
    }
}
```

理解：感觉就是用组合替换继承



参考：

1. https://time.geekbang.org/column/article/202786
2. https://zhuanlan.zhihu.com/p/58903776
3. https://www.jianshu.com/p/61ad71954c74