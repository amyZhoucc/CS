# 进程 & 线程

# 1. 进程

## 1.1 概念

概念：进程是资源分配的单位

进程包含：代码段 + 数据段 + 程序计数器 + 堆 + 栈

注意：

1. **程序本身不是进程**，程序是被动的实体；进程是活动实体。
2. 多个进程可以执行同一个程序，但是它们分别是单独的执行序列。
3. 进程本身也是一个环境，可以来执行其他代码，例如JVM，本身是一个进程，但是它可以解释Java程序并执行。

### 1.1.1 进程状态

基本：5态（不同的OS，有不同的状态，但是基本的都有）

**创建态new**：正在创建

**运行态running**：获得cpu，正在执行

**就绪态ready**：等待cpu

**等待态waiting**：等待发生某个事件

**终止态terminated**：进程执行完毕

（注意和Java的线程状态有所不同，没有阻塞态，是合并在等待态中，Zephyr中存在挂起状态，suspend）

还有的OS会引入挂起状态：（和wait不一样，**没有因为某个明确事件引起的**）

引入的原因：

1. 终端用户的请求

   当终端用户在自己的程序运行期间发现有可疑问题时，希望暂时使自己的程序静止下来

2. 父进程请求

   父进程要求挂起某个子进程，以便考查和修改该子进程，或者协调各子进程间的活动。

3. 负荷调节的需要

   可由系统把一些不重要的进程挂起，以保证系统能正常运行

4. 操作系统的需要

   以便检查运行中的资源使用情况或进行记账。

eg：zephyr就是引入了挂起状态

<img src="C:\Users\surface\AppData\Roaming\Typora\typora-user-images\image-20210227202635809.png" alt="image-20210227202635809" style="zoom:80%;" />

### 1.1.2 进程控制块

PCB的主要信息：

- **进程标识符pid**：**惟一地标识一个进程**

  一般有2种标识符：

  1. 内部标识符，就是一个需要。进程init序号为1，表示原始进程
  2. 外部标识符。它由创建者提供，即名字

  为了描述进程的家族关系，通常有父进程标识及子进程标识，还可设置用户标识，以指示拥有该进程的用户

- CPU状态：主要就是用来上下文切换保存的，切出去保存，切回来恢复

  1. 通用寄存器
  2. 程序计数器PC：下一条要执行的指令
  3. 程序状态字PSW：状态信息，如条件码、执行方式、中断屏蔽标志等
  4. 用户栈指针：指向进程所拥有的栈的栈顶

- 进程调度信息

  1. 进程状态
  2. 进程优先级
  3. 其他和调度相关的信息，eg：使用CPU的总和等
  4. 事件，从running变成waiting的在等待的事件

- 进程控制信息

  1. 程序和数据的地址：进程的程序和数据所在的内存或外存地(首)址
  2. 进程同步和通信机制
  3. 资源清单：该进程已经获得的IO设备列表等
  4. 链接指针：指向该队列的下一个PCB

**PCB的组织形式：链接、索引**（构建索引表查询）

在Zephyr/Linux中活动的进程都是用一个双向链表存储的，用current指向当前进程。

系统为每个进程定义了一个数据结构，即PCB。PCB是进程存在的惟一标志，由于PCB经常被系统访问，所以应该常驻内存。

系统将所有的PCB组织成若干个链表(或队列)，存放在操作系统中专门开辟的PCB 区内——其实，也就是记录了当前OS有多少存活的进程。

## 1.2 进程调度

会有一个**进程调度器**来选择哪一个ready进程去获得CPU。（进程调度器只是概念，底层是由代码和数据结构组成的一个调度机制）

### 1.2.1 进程队列

系统中存在很多队列：**进程队列**——存放所有存活的进程的；**就绪队列**——存放所有等待CPU的进程；**设备队列**——等待特定IO设备的进程的——一般称为阻塞队列，它们是因为拿不到资源所以被挂在该资源的队列上的

进程可以分为：

- I/O密集型：执行I/O比执行计算的时间要多
- CPU密集型：执行计算较多

### 1.2.2 进程调度

调度方式分为：长期调度程序 和 短期调度程序：

- 长期调度程序：将进程从**磁盘等外部设备的缓冲池中加载到内存**。**执行频率低**，可能一个进程执行完成才有一个新的进程加载到内存中。

  主要是用来控制内存中的进程数目，在实时系统、分时系统中通常不用（Zephyr没有）

- 短期调度程序：从ready进程中选择进程获得CPU。执行频率高，所以选择需要快速，例如O(1)时间复杂度

长期调度程序需要对这两类进程做好均衡，如果I/O密集型进程太多，导致CPU利用率较低

后面又增加一个中期调度：可以将进程从内存中换出，后面又可以换入（长期调度程序只能一次加载，直到进程执行完成之后都不会切出）

### 1.2.3 上下文切换

就是CPU从一个进程切换到另一个进程，那么前一个进程需要保存当前的状态，而另一个进程需要恢复到之前的状态

而这个状态就是进程的上下文：主要就是PCB中的信息：CPU寄存器的值、进程状态、内存管理信息等

上下文切换的时间跟硬件相关。

## 1.3 进程的运行

进程控制是进程管理的基本功能，即进程这几个状态之间的切换

进程控制一般是由OS的内核中的原语来实现的。

原语：若干条指令组成的，用于完成一定功能的一个过程，且能保证原子性

### 1.3.1 进程的创建

创建进程的进程：父进程；被新建出来的线程：子进程

——能够构成一棵**进程树**

子进程可以继承父进程所拥有的资源，例如，继承父进程打开的文件，父进程所分配到的缓冲区等。当子进程被撤消时，应将
其从父进程那里获得的资源归还给父进程。此外，**在撤消父进程时，也必须同时撤消其所有的子进程**。

在PCB 中都设置了**家族关系表项**，以标明自己的父进程及所有的子进程。

注意，**子进程可以获取父进程的资源**，父进程也能向子进程传递初始化的数据、传递资源等

父进程创建子进程后，有两种执行可能：

- 父进程和子进程并发执行
- 父进程等待子进程执行完毕

子进程的地址空间的内容可能有：

- 子进程是父进程的复制品，完全一样的数据和程序
- 子进程加载另一个程序

UNIX的**`fork()`**：创建子进程

一般创建完成后，子进程都会去调用**`exec()`**：子进程导入新的程序（当然也可以不调用，两个进程并发执行）

如何触发进程创建：

- 用户登录：为终端创建一个进程
- 作业调度：某个作业需要执行，为该作业装入内存，分配资源，创建进程
- 提供服务：用户程序提出请求
- 应用请求：进程自行创建子进程，让子进程完成特定任务

进程创建流程：

- 申请空白PCB
- 为新进程分配资源
- 初始化PCB
- 将新进程插入就绪队列

### 1.3.2 进程的终止

一般都是进程主动的，调用exit()来终止自身

进程也可以通过系统调用，终止另一个进程，**一般是一个父进程去终止一个子进程**，但是需要父进程知道该子进程的标识符。（所以一个进程应该在PCB中维护所有子进程pid的信息）

父进程系统调用**wait()**，可以等待子进程终止，并且该系统调用会返回子进程的pid，那么父进程可以知道哪个子进程终止了。

子进程终止时，所占用的资源会被释放，但是在**进程表中的条目还是存在，直到父进程调用wait()**——即子进程在执行完成后，父进程还未执行到到wait()语句

此时的子进程进入了：**僵尸进程**（所有进程终止时都会进入该状态）

父进程执行了wait语句后，子进程的条目和pid都会被释放，此时进程才算完全消失。

**孤儿进程**：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被**init进程(进程号为1)**所收养，并由init进程对它们完成状态收集工作。init进程会定期调用wait()，用来收集关于孤儿进程的退出情况

进程终止的步骤：

- 从PCB 集合中检索出该进程的PCB
- 若被终止进程正处于执行状态，应立即终止该进程的执行
- 若该进程还有子孙进程，还应将其所有子孙进程予以终止——**级联终止**
- 将被终止进程所拥有的全部资源，或者归还给其父进程，或者归还给系统。
- 将被终止进程(PCB)从所在队列(或链表)中移出

### 1.3.3 进程阻塞与唤醒

引起阻塞or唤醒的原因：

- 请求系统服务：某个资源暂时不可得，需要等待
- 启动某种操作：某个IO设备尚未完成，而必须等待
- 新数据尚未到达：等待其他一个进程的数据，但是尚未获得
- 无新工作可做：eg：发送进程，但是无数据需要发送等待

## 1.4 进程间通信

进程间通信的概念：至少两个进程间传送数据或信号的一些技术或方法。 进程是计算机系统分配资源的最小单位。 每个进程都有自己的一部分独立的系统资源，彼此是隔离的。 为了能使不同的进程互相访问资源并进行协调工作，才有了进程间通信。

通信的原因：**进程之间需要进行协作**，一个进程影响另一个进程或者受到其他进程的影响。

进程协作的原因：

- 信息共享
- 计算加速：可以将任务分解成一个个子任务，然后并行执行，最后进行合并
- 模块化
- 方便

——协作的进程就需要：**进程间通信IPC**，那么进程之间就可以交换数据了。

IPC有两种模型：共享内存、消息传递

- 共享内存：可以**传递大块的数据**，只需要在创建的时候进行系统调用，而创建完成后，只需要常规内存访问即可；
- 消息传递：在传输较少的数据的时候有用。但是由于**每次操作都需要进行系统调用**；

在多核系统上，**消息传递性能较高**，因为不需要考虑共享内存的cache一致性的问题。

<img src="pic\image-20210406131022659.png" alt="image-20210406131022659" style="zoom:67%;" />

### 1.4.1 共享内存

eg：生产者-消费者问题的解决方案之一。

就是创建一个缓冲区，生产者填充，消费者清空，两者并发执行。并且，它们之间需要实现同步，即消费者不能消费一个还未产生的数据。

缓冲区有两种类型：

- 有界缓冲区：缓冲区大小固定。那么消费者在空的时候要等待；生产者在满的时候需要等待
- 无界缓冲区：缓冲区无限，那么生产者永远不等待。

数据结构：

```c
#define BUFFER_SIZE 10
typedef struct {
    . . .
} item;

item buffer[BUFFER_SIZE];
int in = 0;			// 表示下一个空位
int out = 0;		// 表示第一个满位
```

当插入一个数据之后，计算`(in+1) % BUFFER_SIZE == out`时，就说明缓冲区已经满了，下次再想插入就需要等待了

### 1.4.2 消息传递

消息传递，可以不适用共享内存来实现通信和同步，在**分布式系统中方便**（通过网络连接不同的主机之间进行通信）

消息传递，那么它们之间需要有通信链路，不关注物理实现，而只关注逻辑实现。

#### 1.4.2.1 直接 & 间接通信

直接通信：两个进程之间直接发送数据。`send (P, message) /receive(Q, message) `

要求：

- 那么两个进程需要先**建立通信链路**，然后才能开始通信。
- 链路两端只有两个进程
- 每个通信进程之间只有一条链路

如果对称寻址，那么需要发送方和接收方同时指定对方；如果是非对称寻址，只需要发送方确定接收方即可。

缺点：一旦一方改变了进程标识符，那么所有与该进程相关的链路需要全部进行修改

间接通信：通过一个中间结点进行通信。典型的是：邮箱。一个向邮箱存放信息，另一个向里面读取信息。

要求：

- 两个进程共享同一个邮箱，两个进程才算是建立了链路
- 一个链路上，可能有多个进程
- 两个通信的进程之间可能有多个链路

邮箱：可以进程拥有 or 操作系统拥有。

- 进程所有，那么邮箱所有者只能读取数据；使用者只能发送数据。进程消失了，邮箱也就消失了，向消失的邮箱发送都会被告知邮箱消失
- 操作系统所有，那么操作系统提供机制即可，进程来创建、删除邮箱；通过邮箱发送和接收信息

#### 1.4.2.2 同步 & 异步通信

包括4个原语：

- 阻塞发送：只有等到接收方或者邮箱接收了，该方法才能返回
- 非阻塞发送：发送之后，直接返回
- 阻塞接收：一直等待信息，直到有信息来了收到了，才能返回
- 非阻塞接收：收到消息 or 收到空消息，均直接返回

#### 1.4.2.3 自动 & 显式的缓冲

总有一个交换队列存在：

- 零容量：不能有消息在等待，一旦发送就要马上接收，否则发送者就会被阻塞，直到接收者来接收——就是阻塞发送
- 有限容量：当队列满时，发送者会被阻塞
- 无限容量：队列长度可以无限，所有消息均可以等待

### 1.4.3 管道

管道本质上就是一个**文件**，前面的进程以写方式打开文件，后面的进程以读方式打开。这样前面写完后面读，于是就实现了通信。实际上管道的设计也是遵循UNIX的“一切皆文件”设计原则的，它本质上就是一个文件。Linux系统直接把管道实现成了一种文件系统，借助VFS给应用程序提供操作接口。

#### 1.4.3.1 普通管道/匿名管道

就是标准的CS方式进行的，产生者向管道写入信息，消费者从管道读取数据。**普通管道是半双工通信的**。

UNIX是将管道作为一个特殊类型的文件，所以访问管道可以通过read/write

普通管道只能由创建进程访问。

常见的情况是：父进程通过管道向子进程进行通信。因为管道是特殊的文件，而子进程继承父进程的打开文件，那么管道也就能继承到了。（子进程通过拷贝父进程的进程地址空间获得同一个管道文件的描述符，除了父子进程外，没人知道这个管道文件的描述符）

并且由于是文件，所以父子双方都能读取和写入。所以在开始通信之前需要关闭未使用端——即，确定哪个是发送方，哪个是接收方

Windows系统中，类似，更显然的：**管道的通信双方有父子关系**

缺点：速度慢、容量有限、只能在父子进程之间进行通信

```c
// 系统调用pipe就可以实现一个匿名管道
#include <unistd.h>
int pipe(int pipefd[2]);
```

——POSIX标准中，对PIPEBUF有长度限制，要求其最小长度不得低于512字节。PIPEBUF的作用是，内核在处理管道的时候，如果每次读写操作的数据长度不大于PIPEBUF时，保证其操作是原子的。而PIPESIZE的影响是，大于其长度的写操作会被阻塞，直到当前管道中的数据被读取为止。

#### 1.4.3.2 命名管道

创建出来的文件类型比较特殊，是p类型。表示这是一个管道文件，系统中就有了对一个管道的全局名称，那么任何两个进程都可以进行通信了。其余底层实现是和匿名管道完全一致的

能够支持双向通信，并且**不一定局限在父子双方**。

UNIX中，命名管道为FIFO。但是只允许**半双工传输**，即可以双向传输，但是不能同时进行，一个时刻只能由一个发送到另一个

Windows，允许全双工通信。

```c
if (mknod(argv[1], 0600|S_IFIFO, 0) < 0) {
    perror("mknod()");
    exit(1);
}
```

参考：

https://zhuanlan.zhihu.com/p/58489873

## 1.5 进程和线程的区别

1. 拥有资源

   进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

2. 调度

   线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

3. 系统开销

   由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

4. 通信方面

   **线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC**。

# 2. 线程

## 2.1 概念

概念：调度的基本单位

**一个进程中可以有多个线程**，它们共享进程资源。

eg：QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。

<img src="pic/thread.png" style="zoom:67%;" >

引入多线程的优势：

1. 响应性：对于交互程序采用多线程，即使一个线程阻塞了，但是其他线程还是可以继续执行的
2. 资源共享：进程之间只能进行共享内存和消息传递来传递信息，但是同一个进程内的线程可以直接使用资源
3. 经济：进程开销昂贵
4. 可伸缩性：线程可以在多个处理器上并行运行，而进程只能运行在一个CPU上

## 2.2 多线程模型

有两种方法来支持多线程：用户线程、内核线程。

- 用户线程：在内核上面，它的管理不需要内核支持
- 内核线程：线程直接受操作系统管理

下面看用户线程和内核线程的对应关系：

### 2.2.1 多对一模型

多个用户级线程对应一个内核线程，如果内核线程被阻塞，那么整个进程就被阻塞了。且不能用于并发系统

### 2.2.2 一对一模型

一个用户级线程对应一个内核线程，并发性更好，且可以用于SMP，但是，由于是一一对应，所以会生成许多内核线程，开销大

——大部分系统实现了

### 2.2.3 多对多模型

即多个用户及线程对应多个内核线程，用户级线程多一点，内核线程个数少一点——多路复用。

## 2.3 线程库

**线程库是库函数的一种**，就是为程序员提供创建和管理线程的API（注意和线程池做区分）

实现线程库函数有2种方法：

1. 在用户空间提供一个没有内核支持的库

   那么API所有代码和数据结构都存放在用户层，所以使用该API只能算是本地调用，而非系统调用

2. 由操作系统直接提供支持的内核级的库

   API代码和数据结构都存放在内核层，使用该API就是系统调用

常见的线程库API：POSIX Pthreads、Windows、Java

- Pthreads：提供用户级或内核级的库
- Windows：内核级的库
- Java：采用宿主的线程库

## 2.4 多线程问题

### 2.4.1 系统调用fork()/exec()

`fork()`是在进程中，用来创建一个单独的重复的进程。

而如果一个线程`fork()`，那么UNIX系统存在两种解决方案：

1. 新进程会复制所有该进程中的线程
2. 新进程只会复制调用了fork()的线程

如果调用了exec()，那么指定的程序会替代整个进程，包括里面的线程。

### 2.4.2 信号处理

在UNIX中，信号用来通知进程某个特定事件已经发生。

信号可以是同步的 or 异步的，取决于事件的来源

事件的处理模式：

- 信号由特定事件发生而产生
- 信号是被传递给某个进程
- 进程一旦收到信号后，需要马上执行

同步信号：eg：非法访问 or 除零，某个进程一旦进行上面的操作就会产生信号，信号会发给自身进程

——同步信号是直接传递给自身

异步信号：其他程序产生的，eg：定时器到期。

但是在多线程的进程下，信号如何传递比较复杂：

- 信号到所适用的线程
- 信号到进程内的每个线程
- 信号到进程内的部分线程

### 2.4.3 线程撤销

线程完成之前终止线程。

场景：多个线程并发获取某个数据，一旦一个线程收到数据后，其他线程应该立即撤销

- 异步撤销：线程立即终止目标线程
- 延迟撤销：目标线程不断检查自身是否应该终止——自己终止自己（类似于Java的中断）

## 2.5 线程的实例

### 2.5.1 Windows线程

Windows支持多线程，且**用户级线程和内核线程支持一对一映射**

线程包含的内容：

- 线程ID：tid
- 寄存器组：CPU的寄存器，来表示处理器的状态
- 用户栈/内核栈
- 私有存储区域：存储运行时库和动态链接库

被称为线程上下文

线程含有的数据结构：

- ETHREAD：执行线程块，线程的指针、线程的程序地址和KTHREAD的指针
- KTHREAD：内核线程块，线程的调度和同步信息，内核栈和TEB指针
- TEB：线程环境块

<img src="pic\image-20210330194354169.png" alt="image-20210330194354169" style="zoom:67%;" />

### 2.5.2 Linux线程

Linux并不区分线程和进程。其实统一用task来表示，而不是线程 or 进程。

系统中每个任务都有一个唯一内核数据结构，只是包含了一系列的指针，指向存储数据的指针，eg：打开的文件列表、虚拟内存等

# 3. 进程调度

## 3.1 调度的概念

由于存在多个进程，如果一个进程因为执行完成/要等待IO等信息，而暂时不占用CPU，那么需要切出去给另外一个进程去使用CPU，这个就引发了调度

不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。

## 3.2 调度程序

这个调度就是：**短期调度程序**，直接从内存中选择一个就绪的进程获得CPU执行。

### 3.1.1 抢占式 & 非抢占式

引发调度的时机：

1. 进程的状态从running变成waiting
2. 进程执行完成，变成terminated状态
3. 进程从等待状态变成就绪状态，eg：IO到来
4. 进程从running状态变成ready状态，eg：出现中断、时间片到期

如果系统中调度状态只能发生在1、2中间的，那么就是**非抢占式调度/协作式**，即一个进程一旦获得CPU，就会一直占用CPU，直到执行完成或者状态变成waiting状态。（中断不算在抢占内）

抢占调度：4个状态均能发生。

但是**抢占调度可能会存在竞争问题**，例如对共享变量的修改等，从而导致操作混乱，结果不确定。

### 3.1.2 调度程序

调度程序是一个模块，它用来且CPU，主要工作有：

- 上下文切换
- **切换到用户模式**
- 跳转到用户程序的合适位置，然后重新开始执行

——这些操作必须要快，因为调度耗时是无意义的，该切换时间被称为**调度延迟**

### 3.1.3 调度准则

就是衡量调度程序优劣的

1. CPU的使用率：要求CPU尽可能地忙碌
2. 吞吐量：单位时间内，进程的完成数量
3. 周转时间：就是进程从提交到从完成花费的总时间
4. 等待时间：这个针对的是在就绪队列中等待执行的时间
5. 响应时间：针对交互系统，发送一个请求到响应该请求的时间

需要根据场景进行优化，不可能做到所有最好。

## 3.3 调度算法

调度算法解决的是：ready队列中选择一个合适的进程获得CPU

### 3.3.1 批处理系统

批处理系统没有太多的用户操作，在该系统中，**调度算法目标是保证吞吐量和周转时间**（从提交到终止的时间）。

#### 3.3.1.1 先来先服务FCFS（非抢占的）

**非抢占式的调度算法**，按照请求的顺序进行调度。

优点：简单

缺点：平均等待时间很长

有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

#### 3.3.1.2 短作业优先SJF（可选择是否抢占）

**非抢占式的调度算法**，按估计运行时间最短的顺序进行调度。

理论上：短作业优先算法是**最优**的，因为给定一组线程，它的机制能保证等待时间最短。但是，**难度在于计算作业的执行时间**

长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

#### 3.3.1.3 最短剩余时间优先SRTF

**最短作业优先的抢占式版本**，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

### 3.3.2 交互式系统

交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

#### 3.3.2.1 时间片轮转RR（抢占的）

将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

**时间片轮转算法的效率和时间片的大小有很大关系**：

- 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。
- 而如果时间片过长，那么实时性就不能得到保证。

#### 3.3.2.2 优先级调度PS（可选择）

为每个进程分配一个**优先级**（PCB中存放），按优先级进行调度。

问题：存在饥饿（同SRTF）

解决方法：为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

#### 3.3.2.3 多级反馈队列（可抢占）

基础：多级队列调度，是将线程划分成不同的类型，固定加入不同的队列，然后每个队列的调度策略可以不同，队列之间存在优先级

eg：**对于前台进程，可以采用FCFS调度，对于后台程序可以采用RR调度**，而队列之间采用固定优先级抢占机制。

多级反馈队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，**每个队列时间片大小都不同**，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。

**每个队列优先权也不同**，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。

进程在刚刚进入就绪队列时候会加入优先级最高的队列，如果在给定的时间片没有完成，就会加入到下一级队列的尾部.....

所以IO密集的进程、交互进程都会在优先级高的队列上，而CPU密集的进程会被逐渐向下移。

为了防止饥饿，会将等待时间很久的进程移到更高优先级的队列上。

可以将这种调度算法看成是**时间片轮转调度算法和优先级调度算法的结合**。

<img src="pic/MFQ.png">

### 3.3.3 实时系统

实时系统要求一个请求在一个确定时间内得到响应。

分为**硬实时和软实时**：

- 硬实时：必须满足绝对的截止时间。
- 软实时：可以容忍一定的超时，关键进程会优先于非关键进程，但是不能保证在要求时间内结束

#### 3.3.3.1 最小化延迟

eg：无人驾驶车辆在发现行人的时候，需要制动，那么发现行人到操作的时间就是一个事件延迟

有2类延迟：中断延迟、调度延迟

- 中断延迟：CPU在收到中断到执行中断处理程序中间的时间

  中断延迟中主要进行的操作：

  1. **完成当前正在执行的指令**
  2. **确定中断类型**
  3. **保存当前进程状态**
  4. **加载特定的ISR执行**

  <img src="pic\image-20210329231452449.png" alt="image-20210329231452449" style="zoom:50%;" />

- 调度延迟：从停止一个进程到重新启动一个进程的时间（由于在调度过程中需要操作内核的部分信息，所以需要禁止中断）
  降低这种延迟的方式：**提供抢占式内核**（因为内核可以抢占，所以经常需要进行上下文切换，所以从性能考虑，调度延迟时间要求很短，所以相比较之下，**抢占式内核的调度延迟要小于非抢占式内核的**）

#### 3.3.3.2 优先级调度（可抢占）

优先级越高表明越要紧急处理，所以优先级调度是合理的。加上可抢占，那么就能处理中断

——但是**只能保证软实时**。

#### 3.3.3.3 单调速率调度（可抢占）

**可抢占式、固定优先级**的策略，来调度周期性任务。

每个周期性任务都会分配一个固定的优先级，**周期越短优先级越高**

#### 3.3.3.4 最早截止期限优先调度EDF

要求：进程在ready前需要告知截止时间，那么调度程序可以根据所有进程的截止时间进行调度。理论上是最佳的。

### 3.3.4 多处理器调度

多处理器调度比单处理更为复杂，没有最优的。

调度的方法分类：

- **非对称多处理**：让一个处理器处理所有的调度决定、IO处理和其他系统活动，而其他处理器只是用来执行用户代码

  有主次之分（现在很多多处理器都这样）

  优点：不需要进行数据共享

  ——那么**该调度就和单核调度一样**

- 对称多处理：每个处理器自己进行调度，处理器们会访问共同的就绪队列（或者自己单独有一个就绪队列），然后自行选择一个进程去执行

在SMP中，会试图避免一个进程从一个处理器迁移到另一个——**处理器亲和性**。

而OS来保证一个进程在一个处理器上避免迁移——**软亲和性**。

SMP的关键：保证负载均衡。

还有一种内存架构，能够影响处理器的亲和性：非统一内存访问架构NUMA——某个CPU访问内存速度比其他部分快

#### 3.3.4.1 负载均衡

负载均衡：将待处理的任务均衡的分配到多个处理器中。

对于每个处理器都有一个私有的就绪队列，那么负载均衡是需要的；如果是多处理器用一个公共就绪队列，那么没有复杂均衡的必要，一旦处理器空闲就会从中拉取进程。

负载均衡的两种方法：主要就是有一个任务周期性的检查每个处理器的负载，如果发现不平衡（到一定程度），就进行操作

- 推迁移：进程从高负荷的处理器推到低负荷的（被动）
- 拉迁移：低负荷的处理器从高负荷的处理器拉进程（主动接受）

——一般OS中是并行存在这两种的。

但是**负载平衡，会导致处理器亲和性消失**，因为进程会在处理器间来回移动

## 3.4 调度算法的实例

### 3.4.1 Linux调度

Linux在2.6之后的版本用的是**完全公平调度程序**

Linux的调度是基于**调度类，每个线程都属于一个类**，而每个类都有特定优先级，针对不同的类有不同的调度算法。

Linux会选择最高优先级调度类的最高优先级的任务，获得cpu。目前有两个类：

1. **CFS调度算法的默认调度类**
2. **实时调度类**

#### 3.4.1.1 CFS调度策略

**CFS没有严格的时间片轮转**，即不是按照优先级来划分时间片长度的，而是为每个任务都**按照“友好值”分配一定比例的CPU执行时间**（友好值低，优先级高）。并且，每个任务都会设定一个**间隔时间**，即下一次执行需要间隔一段时间。——目标延迟。

**CFS没有直接分配优先级**，而是记录**虚拟执行时间vruntime**，就是记录任务已经执行的时间，根据友好值来确定衰减因子（友好值低的，衰减更慢），从而确定下一段的时间片长度。

如果默认优先级的任务运行200ms，那么vruntime=200，那么较高优先级的任务运行200ms，那么它的vruntime <200，较低优先级的任务运行200ms，那么它的vruntime>200，所以只需要选择vruntime最短的就是优先级最高的任务

CFS的数据结构：**红黑树，基于vruntime的比较器**，每个可执行的任务都存放在红黑树上

所以根据二分搜索树的特性，最高优先级的任务就是在红黑树的最左边，查找时间是O(logN)，但是为了提高效率，会将最左侧结点缓存在一个变量中

#### 3.4.1.2 实时调度

采用SCHED_FIFO、SCHED_RR调度，实时调度类有更高的优先级。0~99范围内，普通任务是100~139，友好值-20~+19分配给普通任务

——优先级越高，数值越小

### 3.4.2 Windows调度

是基于优先级的、可抢占的调度算法。还有时间片轮转，类似于多级反馈队列

有**调度程序**专门来处理调度

线程有优先级：32级优先级：

- 可变类：1~15优先级
- 实时类：16~31优先级
- 优先级0：有且仅有一个线程，用来进行内存管理
- 还有一个空转线程

每个优先级均有一个队列，从最高优先级开始找，直到找到第一个线程开始执行。如果没有线程，那么执行空转线程

线程分类：（从上到下优先级逐渐降低）

- REALTIME_PRIORITY_CLASS：实时类——24（优先级基值）
- HIGH_PRIORITY_CLASS：高优先级类——13
- ABOVE_NORMAL_PRIORITY_CLASS：高于常规类——10
- NORMAL_PRIORITY_CLASS：常规类，通常都属于此类——8
- BELOW_NORMAL_PRIORITY_CLASS：低于常规类——6
- IDLE_PRIORITY_CLASS：空转类——4

除了实时类，其他类的线程优先级都是可变的

给定了线程的类，而该线程也还有一个相对优先级：

- TIME_CRITICAL
- HIGHEST
- ABOVE_NORMAL
- NORMAL
- BELOW_NORMAL
- LOWEST
- IDLE

（和上面的类似）

——**每个线程都有一个优先级的类型和在该类型中的相对优先级**

一个线程的时间片用完后，线程被中断，如果它属于**可变优先级，那么降低其优先级**，但是不会低于基准优先级。然后，一个线程从**等待队列回到ready队列，其优先级会升高**，升高的大小取决于在等待什么资源，如果是IO资源，那么提升最多，磁盘次之。

那么IO密集型的线程能够保持忙碌，且在空闲的时候CPU密集型程序可以得到执行。

Windows对于交互程序做了特殊的策略：对于NORMAL_PRIORITY_CLASS，将其分为**前台进程——屏幕上选择的进程和后台进程——屏幕上未选择的进程**，当一个进程移动到前台，会增加其时间片，为原来的3倍

Windows7下增加了用户模式调度，就是允许应用程序在内核外创建和管理线程，对于有大量线程的应用程序，由于不要进行系统调用，所以性能较好。