# 1. 文件系统

文件系统由两部分构成：

- **文件集合**：就是文件本身，每个文件都存储相关数据
- **目录结构**：组织系统内的所有文件，并提供文件信息

## 1.1 概念

产生文件系统的原因：为了方便用户使用，OS提供了信息存储的统一逻辑视图。所以文件是一种逻辑概念（实际上底层就是0/1串）

文件：操作系统对存储设备的物理属性加以抽象，**定义了逻辑存储单位**，就是文件。文件由操作系统映射到物理设备上。

**从用户角度：文件是逻辑外存的最小分配单位**，即任何的数据都需要通过文件才能存储到外存上。

文件可以存储：数据和程序，可以是任意形式的。

### 1.1.1 文件属性

文件可以被命名，可以通过文件名进行引用。

当文件被命名之后，它就独立于进程、用户、系统而存在。eg：移动到U盘，通过邮件发送出去

文件属性常见的有如下：

- 名称：对人可读的标志一个文件的
- 标识符：通常为数字，对于用户来说不可读
- 类型：支持不同类型的文件有该功能，eg：txt文件、word文件
- 位置：设备上存放该文件的指针
- 尺寸：该文件的大小，字节 or 块等
- 保护：控制读写、执行，chmod 777
- 时间、用户标志：创建、最后修改等信息，主要是用来进行保护和状态监控

有些还支持**扩展文件属性**，主要是对文件的字符编码、安全功能等，eg：文件校验和

这些信息都被保存在目录结构中，而目录结构也是保存在外存中的，根据需要调入内存。

### 1.1.2 文件操作

#### 1.1.2.1 文件基本操作

文件有6个基本操作：

1. 创建文件

   需要两步：为文件分配内存空间，在目录中创建新的文件条目

2. 写文件

   系统调用

   传递：目标文件和要写入的内容。

   系统有一个**写指针，指示文件中下一次写入的具体位置**。然后每次写入后，都需要更新写指针

3. 读文件

   系统调用

   传递：目标文件和数据应该写入内存哪里

   系统需要有一个**读指针，指示下一次读取操作的文件位置**。每次读取之后，需要更新读指针

   读写指针可以合并为**当前文件位置指针**，使用这一个就能表示读写了

4. 重新定位文件

   在目录中找到指定条目，更新文件位置指针，那么该文件名对应的具体数据就到了一个新的地方了。

   不用涉及任何IO

5. 删除文件

   在目录中找到指定文件名的条目，然后删除该条目并释放占用的文件空间。

6. 截断文件

   删除文件内容，但是保留属性（除了文件尺寸属性），然后文件内容全部释放。

eg：那么复制文件，就是将创建一个新的文件，然后从旧文件中读数据，写入到新文件中——通过上面的6种组合就能实现复杂的操作。

#### 1.1.2.2 文件打开

可以发现，如果需要操作一个文件，需要先在目录中查找，然后找到指定条目后，才能继续进行操作

所以，为了避免每次调用上面6个需要去查找一遍，所以**在首次使用文件之前进行系统调用open()**（大部分操作系统都需要显式地open，而不能隐式），open会去查看该文件的权限，如果open的请求模式是文件允许的，那么能打开文件。

操作系统维护一个**打开文件表，维护了所有打开文件的信息**。那么当对文件进行操作时，不需要再进行目录搜索。当进程不需要使用之后，调用close来显式关闭文件，操作系统会将该文件从打开文件表中删除。（那么下一次需要操作该文件时，又需要open，去搜索目录）。

对于并发环境，操作系统维护：每个进程的打开文件表和系统打开文件表。

- 进程表追踪打开的所有文件

  存储进程对文件的使用信息，eg：当前文件位置指针、文件权限等

  也会有一个指针指向系统表的对应条目

- 系统表存储的是进程无关信息

  存储的是：文件在磁盘上的位置、文件大小等。

  当进程打开一个新的文件时，系统表中也会增加一个。

  系统为每个文件维护一个**打开计数**，每当有一个进程打开这个文件，计数++；close该文件，计数--，只有当计数为0时，表示没有进程在使用，那么将该条目从系统表中删除

所以文件附带有如下关联信息：

1. 当前文件位置指针
2. 文件打开计数
3. 文件的磁盘位置
4. 访问权限

针对并发情况：还有**文件锁**，能够实现共享锁、独占锁（有的os只实现了独占锁）

操作系统可以建议 or 强制使用文件锁定机制：

- 建议锁定机制：及时获得了独占锁，其他进程还能访问该文件，开发人员需要自行保证并发操作的正确性，手动加锁和解锁。eg：UNIX
- 强制锁定机制：一旦获得了独占锁，操作系统就不允许其他进程再访问该文件，操作系统能够保证锁的完整性，即再获得锁之后直到释放之前，不会有其他进程能够获得成功。eg：Windows

当然，锁的通用问题：需要防止死锁；对于强制机制，只有当访问文件时才使用锁，否则其他进程就一直访问不了该文件了

### 1.1.3 文件类型

大部分操作系统支持用户将类型名也作为文件名字符序列的一部分，跟在最后面`.docx`。

<img src="pic\image-20210405104700325.png" alt="image-20210405104700325" style="zoom: 43%;" />

`.com/.exe/.sh`才是 可以直接执行的文件：`.sh`：是shell脚本，包含了ASCII格式的操作系统命令；`.com/.exe`是二进制可执行文件。

## 1.2 文件访问方法

### 1.2.1 顺序访问

文件信息按照顺序加以处理。eg：编译器、编辑器就是这样读取和写入文件的。

主要的操作：`read_next()\write_next()\reset()`读下一个、写下一个、向前或者向后跳过n个记录等

### 1.2.2 直接访问

文件由固定长度的逻辑记录组成，允许程序按照任意顺序写入或者读取

对于大量信息的立即访问，直接访问文件效率更高，eg：数据库，先计算哪个块中包含答案，然后直接读取该块，其实就是块号和内容存在一定的逻辑关系，可以进行直接定位。

——具体看操作系统支持哪种访问方式。

## 1.3 目录与磁盘结构

一个磁盘可划分为多个分区。分区用来限制文件系统的大小，那么多个类型的文件系统会放在同一个磁盘下面。磁盘的每个分区都可用于创建文件系统，也可以不创建文件系统，直接使用原始分区。

**包含文件系统的分区称为卷**。

<img src="pic\image-20210405134212560.png" alt="image-20210405134212560" style="zoom: 67%;" />

### 1.3.1 目录概述

目录的功能：

- 搜索文件，并且还要能支持匹配特定模式的所有文件

- 创建文件

- 删除文件

- 遍历目录

- 重命名文件

- 遍历文件系统

  访问每个目录和目录结构内的文件。

  为了可靠性，定期备份整个文件系统的内容和结构

下面需要了解一下目录的组织形式：

### 1.3.2 单级目录

所有文件都包含在同一目录下面。（不论是哪个用户）

文件数量增加 or 用户数量增加时，受到了限制。

因为，在同一目录下，文件名必须唯一。

### 1.3.3 两级目录

为每个用户单独创建一个目录。每个用户都有自己的**用户文件目录UFD**。用户登录时，搜索系统的主文件目录MFD，然后匹配对应的用户名，找到对应的UFD。当用户查找文件时，都只在自己的UFD中找

它实现了用户之间的完全隔离，能够保证数据的安全性；但是，用户之间如果需要合作访问彼此文件时，隔离是一个缺点。

如果允许跨用户的文件访问，则需要在文件路径前面带上用户名。

如果要访问的是系统文件，则标准解决方案是：定义一个特殊的用户目录，包含系统文件。当需要加载指定的文件时，先在本地用户这边查找，如果找不到就去搜索特殊用户目录。

——Windows和UNIX常用的。

### 1.3.4 树性目录

是两级目录的推广。

目录本身包含了一组文件或子目录，目录本身也是文件，但是是按照特殊方式处理的文件。

在常规使用的时候，每个进程都有一个当前目录，当前目录包含进程感兴趣的大部分文件，当引用一个文件时，从当前目录里面找，如果找不到，需要用户指定一个路径名，或者改变当前目录到包含该文件的目录。

<img src="pic\image-20210405141914955.png" alt="image-20210405141914955" style="zoom:80%;" />

路径有两种：绝对路径名：包含从根节点到指定文件的；相对路径名：从当前目录开始到指定文件的。

允许用户自定义子目录，`mkdir dirName`，可以按照一定结构来组织文件。

删除目录，如果目录为空，则简单删除即可。而如果目录下面还存在内容，则有2种处理方案：

- 有的系统不允许删除目录，除非为空。所以可能需要递归删除里面的所有子目录下面的文件，才能将子目录删除，才能最终将目录删除
- 有的系统说要删除，那么就将该目录下的所有全部删除——简单，可能存在误删的风险。

### 1.3.5 无环图目录

树性结构的目录，禁止共享文件和目录。而如果两个子目录需要共享就需要无环图——同一个文件 or 子目录可以出现在两个不同的目录中。

注意：共享文件，不是副本，系统中只有这一个文件，如果一个用户对其进行修改，那么其他用户马上就能看到。

<img src="pic\image-20210405143144506.png" alt="image-20210405143144506" style="zoom: 67%;" />

共享文件和目录的方式：

1. 链接

   在目录中创建名为链接的条目，里面存放着对另一个文件 or 目录的指针。和原来的条目是不一样的

   链接可以用绝对路径 or 相对路径。

2. 在共享目录中复制有关文件 or 目录的全部信息，所以它们的条目内容是完全一样的

   存在的问题：在修改文件时需要保证一致性。

如果在共享系统中，删除文件 or 目录该如何处理：

- 链接：

  删除链接不影响文件本身；删除文件本身，那么原来的链接都悬空了，而如果遍历所有的链接进行删除代价太大（因为文件没有设计关联的链接列表）；所以常用的是：不关注这些链接，直到尝试使用然后发现链接的地址不可达

  ——UNIX/Windows都是忽略符号链接，用户需要自行保证原来的文件被删除的情况

- 保留文件，直到它所有的链接都被删除了，才能将文件删除。那么需要维护一个引用计数。

  ——UNIX对硬链接采用了这种方法。

### 1.3.6 通用图目录

无环图是比较理想的思路，它的难点在于：**如何保证没有环**

无环图，能够通过对树的简单遍历来判断该文件是否还有其他引用。而如果图一旦出现环，就可能出现无穷搜索。

为了防止无穷搜索，可以限定访问目录的数量。

并且，无环图可以保证当引用计数为0时，就没有其他目录在引用该文件了；而有环图，可能存在自我引用。这时需要垃圾收集方案。

——非时，很少使用，但是是必须存在的，因为目录中存在环。

简单处理链接导致潜在环的问题：在遍历目录的时候避开链接。

## 1.4 文件系统的安装

文件系统在使用之前，必须先挂载到设备上，位置就被称为**挂载点**。

然后，操作系统会去验证该设备是否有一个有效的文件系统：通过设备驱动程序读入设备目录，然后验证目录有预期格式——那么，该文件系统已经正确安装到挂载点上了。

eg：Windows系统会自动发现所有设备，并安装所有找到的文件系统。

## 1.5 文件共享

大多数系统为了实现文件共享，**采用文件所有者和组group的概念**。

对于文件所有者，它有最高权限，更改属性和授予访问权限；

对于组，在同一个组内的用户有相同的访问权限

一致性语义：主要涉及到多用户访问，并且由于磁盘速度很慢，所以一般都会将文件传输到内存中进行访问。那么就存在局部可见性。为了保证内存一致性语义，所以需要做出规定。

eg：UNIX语义：

UNIX文件系统要求：

- 一个用户对于已经打开文件的写入，其他同样打开该文件的用户应该立即可见

  修改了，大家都可见

- 共享模式下，进程间可以共享文件的当前位置指针，一旦修改该指针位置，会同步到其他进程

## 1.6 保护

对于文件来说，主要是对于文件访问的控制。

### 1.6.1 访问类型

需要知道，文件有哪些访问类型：

基本访问类型：

- 读访问
- 写访问
- 执行：读取文件到内存并执行里面的内容
- 添加：在文件末尾添加新的信息
- 删除
- 列表：列出文件的名称和属性

其他高级的访问都是通过该6种低级的访问的组合进行的。所以系统只需要保护这6种低级的访问即可。

eg：复制，那么只需要对该文件有读权限，就能实现

### 1.6.2 访问控制

是通过用户身份来控制访问的。

实现方式：**为每个文件或目录，添加一个访问控制列表**，可以指定某个用户 or 组 的访问类型。

所以用户在访问某个文件前，会先检查访问控制列表的权限，如果有权限则继续，没有就拒绝。

有3种用户类型：

- 所有者：拥有最高权限
- 组：用户的集合
- 其他：系统内的其他用户

eg：在UNIX中

只有管理员和超级用户才能创建和修改组。

它定义3个域来进行保护：所有者、文件组、其他用户

每个用户有一个域，域里面有3位：rwx，分别代表读、写、控制执行。

所以每个文件需要9位来表示访问控制：

eg：rwxrw-r--：表示对于所有者能读、写、控制；对于组用户能读、写；对于普通用户能读。

所以，经典的`chmod  777 /etc/squid`，表示该目录给所有用户都有读、写、控制权限。

这9位后面增加了+，表示该文件有可选的ACL许可。

当ACL和权限冲突时，一般选择ACL优先。

# 2. 文件系统的实现

磁盘中维护了文件系统。

为了提高内存和磁盘的IO效率，它们之间的传输按照块为单位执行。

## 2.1 文件系统的结构

文件系统的实现，主要有两个问题：对上，如何给用户提供接口；对下，如何将逻辑的文件系统映射到物理外存设备中。

- IO控制层

  设备驱动程序和中断处理程序，主要涉及到的都是IO操作，本质上是磁盘和内存之间的信息传输

- 基本文件系统

  向设备驱动程序发送通用命令，以读取和写入磁盘物理块。命令例如：将驱动器1，柱面72，磁道2，扇区10读入内存位置1060

  也管理内存缓冲区、保存各种文件系统、目录和数据块的缓存。

- 文件组织模块

  将文件的逻辑地址转换成物理块地址，从而实现基本的文件系统传输。

  每个文件的逻辑块是从0~N进行编号的，而物理块不是，所以需要通过转换来定位块。

- 逻辑文件系统

  管理元数据信息。元数据包括文件系统的所有结构，但是不包括文件内容信息。

  逻辑文件系统管理目录结构，通过文件控制块FCB来维护文件结构

  （FCB：包含文件的信息，包括所有者、权限、内容的位置等信息）

  文件保护

<img src="pic\image-20210405181358524.png" alt="image-20210405181358524" style="zoom:67%;" />

分层有助于降低复杂性和冗余性，但会增加开销并降低性能

操作系统中可能都有自己的格式，

**Linux的标准文件系统是可扩展文件系统**

## 2.2 文件系统的实现

### 2.2.1 概述

文件系统包含如下信息：

- 每个卷的引导控制块：从该卷引导操作系统所需要的信息，一般是bootloader。它通常为卷的第一块。

  UFS称为引导块，NTFS称为分区引导扇区

- 每个卷的卷控制块：包括卷的详细信息，eg：块的大小、数量、空闲块的数量和指针、空闲FCB的数量和指针等

  在UNIX文件系统UFS中称为**超级块**，NTFS中称为**主控文件表**

- 每个文件系统的目录结构

- 每个文件的FCB

内存中保存了一些信息用来管理文件系统，在安装文件系统的时候被加载，在操作文件期间被更新，在卸载文件系统时被删除

- 内存中的挂载表：包含每个挂载的卷的信息
- 内存中的目录结构的缓存，包含最近访问的目录信息
- 整个系统的打开文件表
- 进程的打开文件表

下面是文件从创建到被删除的流程：

1. 创建：

   系统调用逻辑文件系统，为新文件分配一个FCB（创建一个 or 从空间的FCB中获取一个）

   然后将目录读到内存中，并且给目录增加一个条目

   对于UNIX，将目录当作文件处理，只不过有一个类型域来表示该文件是目录；Windows，将目录特殊处理

2. 在使用之前，先打开

   系统调用open，从应用程序传递到逻辑文件系统，系统先在系统打开文件表中进行查找，看该文件是否已经被打开：

   - 打开，则进程的打开文件表创建一个条目，该条目直接指向系统文件打开表
   - 尚未打开，通过给定文件名去搜索目录结构（在内存中有缓存，先搜索内存，后搜索磁盘的），找到该文件后，该文件的FCB会被存放到系统的打开文件表中，并且还会记录打开的进程数；然后再在进程中创建对应的条目
   - 进程中还会存放一个域，包含文件的当前位置指针和打开文件的访问模式。

3. 关闭文件

   该进程会关闭文件后，将打开文件表的对应条目删除，而整个系统的对应条目的打开数量--。当所有进程都关闭它之后，系统的打开文件表中也会将该条目删除。

### 2.2.2 分区与安装

一个磁盘可以有多个分区，而一个卷可以跨越多个磁盘的多个分区。

分区：没有文件系统——raw，eg：交换空间就是用原始磁盘；有文件系统——熟的

引导程序是没有文件系统的，因为此时操作系统还未初始化，所以谈不上有文件系统。所以，引导信息一般都是几个连续的块，将其加载到内存中执行。

根分区：就是存放操作系统和其他系统文件的，在启动时安装。所以，操作系统也会在这个时候对文件系统进行验证：从磁盘中读取设备目录，验证目录是否符合预期格式。验证成功后，操作系统会在安装表中记录：已经安装的文件系统和对应的类型

eg：Windows会将每个卷都分开安装，用字母+冒号表示

F: 表示文件系统已经安装在F: 上，会在该设备对应的域中加上一个具体的指针。当进程需要访问时，可以通过F:来进行找到适合的指针，然后进行访问。

UNIX将文件系统安装在任何目录上

### 2.2.3 虚拟文件系统的实现

由于可以存在多种文件系统，那么操作系统如何实现统一操作的呢？

用3层来实现：

- 文件系统接口，基于open、write、read、close
- 虚拟文件系统VFS，提供了一种实现文件系统的面向对象的方式，对上屏蔽下层文件系统的差异，从而实现一个统一的文件接口

<img src="pic\image-20210405214510543.png" alt="image-20210405214510543" style="zoom: 80%;" />

Linux的VFS架构，有4个主要对象类型：

- **索引结点对象inode**，表示一个单独的文件
- 文件对象，表示已经打开的文件
- 超级块对象，表示整个文件系统
- 目录条目对象，表示单个目录条目

针对这4个对象，都定义了一组操作，构建了一个函数表，每个对象都有一个指向对应函数表的指针。

上层的4个函数到VFS这一层，都通过该对应对象的对应函数实现了

## 2.3 目录的实现

### 2.3.1 线性列表

最简单：文件名称-数据块指针的线性列表。

但是，查找耗时大。

如果是数组，删除一个条目耗时；如果是链表，删除耗时小；排序数组可以进行二分查找，但是文件创建、删除更加复杂了。

较优的是选择红黑树等。

### 2.3.2 哈希表

利用文件名可以直接计算出存储的位置，查找速度快。但是存在的问题是，扩容、哈希冲突的问题

## 2.4 分配方法

主要是如何为文件分配磁盘空间，使能够高速地访问和有效利用空间。

### 2.4.1 连续分配

文件在磁盘上**占有连续的空间**。

那么文件就是：首块的磁盘地址 + 连续的块数。如果要访问整个文件，那么磁盘的寻址时间最短：因为都是连续的，所以只需要稍微移动一下磁头，就到下一块了。

并且通过计算，可以直接得到第i块的块号，所以**支持直接访问**。

<img src="pic\image-20210405195407052.png" alt="image-20210405195407052" style="zoom:67%;" />

存在的问题：

1. 新文件找空间比较麻烦，见缝插针，就是要在零散的连续空间中找到合适大小的空间分配，容易造成外碎片

   分配的方式用到first-fit/best-fit

   解决外碎片的方法：将内容完全移动到另一个磁盘，当前磁盘清空后，分配连续的空间给这些文件——合并。但是，时间代价较大。

2. 需要提前确定一个文件需要的空间，扩容不容易，即使提前计算好空间，但是有一段时间内碎片较多

   由于要求是连续的，所以块之间不能分开

   解决方法：找一个更大的空间复制过去

   改进版：扩容空间不够，就在其他地方找一块空间，然后再文件地址记录中记录下一扩展块的首地址。

### 2.4.2 链接分配

文件的磁盘块可能分布在各个位置。每一块都有一个指针指向下一个块。

eg：块大小为512B，那么有4B来存放指向下一块的指针。

文件信息条目：存储文件首个磁盘块的地址。文件刚初始化时，该指针为null

优点：没有外碎片，没有使用的每一块都可以分配

缺点：

1. 只能**支持顺序访问**，访问下一个块都需要进行磁盘读，甚至还需要磁盘寻道时间

2. 指针空间消耗较大。

   解决方案：将块组成簇，按簇分配而不是按块（就是合并一下块，变成一个大的空间，从而减少链表长度），那么指针消耗少。但是，相应容易产生内碎片

3. 可靠性：如果指针丢失 or 损坏，文件的后半部分就找不到了

   解决方案：采用双向链表——空间开销更大了；每个块均存储文件名和相对块号，开销也变大了

扩展：**文件分配表FAT**：

- 在每卷开头的磁盘中，存储该表，每个表有index-value，index就是对应的块号；value对应的是文件中下一个结点的index
- 直到该文件的最后一块，设置为文件结束符；
- 而没有被使用的块标记为0，当其被调用的时候，用该新块的地址替换前一个块的文件结束符；而新块的value变成文件结束符

<img src="pic\image-20210405201814931.png" alt="image-20210405201814931" style="zoom:67%;" />

优点：改善随机访问的时间，通过查表能定位到文件的随机一块的位置

劣势：磁头需要移动2次，移到卷的开头找一次，然后再移动到块的具体位置

### 2.4.3 索引分配

每个文件都有自己的索引块，记录哪些块是该文件占有的。索引块的第i条对应了文件的第i块——所以**支持直接访问**。

没有外部碎片，

缺点：

1. 索引分配浪费空间，一般索引消耗的空间大于链接分配的空间

2. 索引块的大小难以确定，太大浪费，太小不够

   - 链接方案：索引块本身就是磁盘块，所以可以将多个索引块链接起来

   - 多级索引：第一级索引块指向第二级的索引块，第二级索引块才指向具体的内容块。并且还能再扩展到多级索引

   - 组合方案：eg：UNIX就是将索引块的前几个指针存储在文件的inode中，eg：前15个。那么1~12个都是指向直接块（对于小文件来说就够了），13~15个都是指向间接块，分别代表一级、二级、三级间接块（就是上面的多级索引）

     ——那么能同时间顾大文件和小文件。

## 2.5 空闲空间管理

位图、链表，不赘述

组，就是在第一个空闲块中存放n个空闲块的地址，那么它指示的n-1个空闲块是空闲的，可以使用；第n个空闲块又存放了接下来空闲的n个块地址。——所以，能找到一批空闲块地址

计数：存放的是第一块空闲地址和紧跟的连续空闲块的数量——就是整理出一个个大块

所以链表中的每个条目存放的是磁盘的地址和数量。所以，链表长度会变短，但是每个条目的内容会变多。

## 2.6 效率 & 性能

效率主要看磁盘分配算法和目录算法，没有最优，只有在指定场景中的较优。

### 2.6.1 性能

系统提供一个缓冲区对文件内容进行缓存。

Linux和Windows都是通过页面缓存来缓存进程页面和文件数据。——**统一虚拟内存**

页面缓存是虚拟内存技术的，是按页面来进行存储，而不是通过文件系统，相比之下虚拟内存技术的效率更高，因为访问接口是通过虚拟内存而不是文件系统（不需要系统调用）

**Linux有部分版本实现了统一缓冲区缓存，内存映射和文件的读取和写入的缓存都使用同一个页面缓存**。——那么可以避免内存映射的双缓存（即虚拟内存系统没有缓存区缓存接口，所以需要对缓存区缓存上再添加一个页面缓存），也能够让虚拟内存系统管理文件系统数据

<img src="pic\image-20210405221221468.png" alt="image-20210405221221468" style="zoom: 67%;" /><img src="pic\image-20210405221230654.png" alt="image-20210405221230654" style="zoom: 67%;" />

文件系统的写入是同步的还是异步的：同步的要求将数据写到磁盘驱动器后才能返回；异步，将数据放到缓冲区后就可以返回。

文件的机制不适用于LRU，因为刚才用过的页面很有可能不会再使用，所以一般采用：随后释放，一旦请求下一个页面，就从缓冲区中删除一个页面。

预先读取，一次读取当前页面以及后面多个页面。

## 2.7 恢复

一致性检查：将目录结构中的数据与磁盘上的数据块进行比较，并尝试解决不一致问题——可能很慢，有时会失败
使用系统程序将数据从磁盘备份到另一个存储设备（磁带，其他磁盘，光盘）
通过从备份还原数据来恢复丢失的文件或磁盘

基于日志的文件系统

