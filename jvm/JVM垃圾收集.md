# 垃圾回收（面试高频）

垃圾回收需要考虑的：

1. 哪些内存需要回收
2. 什么时候回收
3. 如何回收

对于线程私有的：==虚拟机栈、本地方法栈、程序计数器会随着线程的消亡而消亡==，分配和回收有确定性，方法结束or线程结束时，内存就一起回收了。——线程私有的内存区域不需要关注垃圾回收。

==对堆的回收==：堆中存放的是对象，所以对堆回收，需要知道的是**哪些对象已经死亡、哪些还存活**。——这个是GC的研究重点

## 4种引用类型

背景：JDK1.2之前，都是只有2种引用：引用 or 不引用

后面进行了4类扩展：

1. ==强引用==：最常见的赋值语句就是强引用，eg：`Object obj = new Object();`，只要这个引用关系还存在，那么GC就永远不会进行回收

2. ==软引用==：非必须，但是还有用的。

   只有在系统即将发生OOM异常时，才会将这些内存区域划入回收范围内进行二次回收。这次回收经过之后，还是OOM，那么才抛出内存溢出异常

3. ==弱引用==：非必须对象，只能生存到下一次垃圾收集发生为止。当前内存足够，也会对弱引用的对象进行回收

4. ==虚引用==：即使有虚引用，也不会影响其生存时间

## 对象的回收机制

### 1. 引用计数算法

对每个对象都增加一个字段：引用计数器，每当有一个地方引用，那么计数++；如果引用失效了，那么计数--。那么引用减少到0就意味着该对象不可能再被利用了。

==优势：简单、判定效率高==。

但是：主流虚拟机都不采用，因为：**需要大量的额外处理才能保证正确地工作，且存在循环引用的问题**。

eg：`objA.instance=objB; objB.instance=objA;`那么objA和objB存在互相引用，引用计数均不为0。如果此时仅有对方还在引用，其他均没有引用，那么实际上两个对象均可以被回收了，但是由于计数不为0，所以还不能回收。

### 2. 可达性分析算法（主流使用）

从==**GC Root**==的根对象作为起始结点开始搜索，根据引用关系向下搜索，然后走过的路径就是==**引用链**==

如果某个对象到GC Root之间没有任何引用链相连，那么被认为该对象不可达，就可以进行回收了。

——所以即使循环引用，只要和GC Root不相连，那么就认为这几个对象不可达。

GC Roots的对象包括以下几种：

1. ==虚拟机栈（栈帧中的本地变量表）中引用的对象==，eg：局部变量、参数、临时变量等
2. ==在方法区中类静态属性引用的对象==，eg：引用类型的静态变量
3. ==在方法区中常量引用的对象==，eg：常量池的引用
4. ==在本地方法栈中Native方法引用的对象==
5. ==被同步锁synchronized持有的对象==
6. JVM内部的引用，eg：基本数据类型对应的Class对象、常驻的异常对象NullPointException等，类加载器

### 3. 对象的自我拯救

如果在可达性分析中被判断为不可达，不会马上被回收，还有被救的机会。——有两次标记机会：

1. 第一次可达性分析后，发现该对象没有和GC Root存在引用链，那么**会被第一次标记**

   然后进行第二次筛选，判断该对象==是否有必要执行finalized()方法==（有再给一次机会的意思）

   如果没有覆盖finalized()方法（没有想自救），或者该方法已经被JVM执行过了（已经自救过一次了）

   如果没有必要执行（即上面的两种情况），那么没有必要进行二次标记，可以直接进入等待回收状态

   如果有必要执行，那么会将对象放在一个==**F-Queue队列中**==，然后虚拟机会创建一个==低优先级Finalizer线程==去执行finalize方法——只能说触发启动，==但是不能保证结束==（因为执行时间未知，所以不会等待其长时间的执行）

2. 在执行finalize之后，会进行对F-Queue对象进行第二次小规模标记，如果对象在finalize中拯救自己——即，重新和引用链上的任何一个对象建立联系，那么第二次标记的时候就不会再被标记，那么就能逃脱，否则就是要被回收了

——那么如果靠finalize方法进行逃逸后，再次面临回收时，finalize方法不会被再次执行，就无法再次拯救了。

——**但是==不建议通过finalize方法进行拯救，因为存在大量的不确定性、代价高、 也无法保证对象的调用顺序等==，所以不建议**

所以，finalize能做的（关闭资源）的清理工作，可以由==**try-finally**==去完成。

## 垃圾收集算法

都是属于追踪式垃圾收集算法。

### 1. 理论：3个

==分代收集==，即对不同的对象分为不同的分代，按照不同的机制进行回收

有2个分代假说：

1. **==弱分代假说==：大部分对象都是朝生夕死的**

2. **==强分代假说==：熬过越多次的垃圾回收，对象就越难消亡**

3. **跨代引用假说：跨代引用相对于同代引用来说仅占小部分**

   合理性：如果跨代之间存在引用，eg：新生代引用老年代，那么由于老年代难以消亡，那么新生代也会逐渐变成老年代，也就不存在跨代的问题了

   操作：==不需要遍历所有老年代，只需要标记老年代的哪些区域会存在跨代引用==，然后每次Minor GC时，只会那一小部分的老年代区域会被加入到扫描中。

一般设计者，都至少将Java堆分为新生代和老年代两个区域：会将Java堆分为**新生代、老年代**，新生代中每次都有大量的对象死去，然后每次都存活的少量的对象就会晋升到老年代中。

minorGC：新生代中的垃圾回收，majorGC：老年代中的垃圾回收

### 2. 标记-清除算法（原始）

先标记要被回收的对象，然后对这些内存区域进行GC

缺点：

1. ==效率未知==，如果区域中大部分都需要删除，那么需要大量的标记和删除
2. ==内存内碎片==，由于清除的位置不确定，所以删除的位置不一定是连续的，可能会造成大量的碎片问题，导致内存分配失败

### 3. 标记-复制算法（在Minor GC中优先采用）

半区域复制。

将内存区域对半分，每次只能使用一半的内存区域。

**当这一块的内存区域用完了**，然后将该区域还**存活的对象**复制到另外一块上，然后将该块内存区域全部清除

所以，如果大部是存活，那么需要大量的移动；而根据弱分代假说，需要移动的会比较少，且不存在内碎片的情况。

==缺点：可用内存减少了一半，空间浪费大==

改进：根据98%策略

1. 将新生代区分为Eden和两块Survivor区，分别是8:1:1
2. 每次使用都是一块Eden和一块Survivor区，然后GC时将这两块的存活对象直接复制到另一块Survivor中——所以只有10%的内存区域被浪费了
3. 但是，还是存在一块Survivor不够用的情况，那么一般由==老年代进行分配担保==，**将这些内存对象直接进入到老年代**

——如果新生代年龄到达15后，就会被移动到老年代。

### 4. 标记-整理算法（针对Major GC，HotSpot选择）

让存活的对象都直接向内存空间的一端移动，然后直接清除掉边界外面的内存——移动的，而原始的标记-清除算法是不移动的

存在问题：根据强分代假说，每次有大量的对象存活，==移动耗时很大==，且必须要暂停用户应用程序才能进行

——但是这样的代价，能够减少碎片（这个会更加影响**系统吞吐量**），所以移动对象更划算

和稀泥方法：==平时采用标记-清除算法，直到碎片情况已经影响到内存分配了，那么才会调用标记-整理算法一次==，然后又有多余的内存空间了

——CMS收集器就是采用这种方法的

## 经典垃圾收集器

首先明确：没有最好的垃圾收集器，也不会存在万能的垃圾收集器。只有对应于某个具体应用最合适的收集器。

### 1. Serial收集器（HotSpot客户端默认的新生代收集器）

最基础。

**单线程工作的收集器：只会使用一个处理器去完成，且在执行的时候需要暂停其他线程的工作，直到收集结束。**

优点：

1. 简单、高效
2. 对于资源受限的环境，是所有收集器中额外开销最小的
3. 单线程收集效率最高

缺点：需要暂停其他工作线程

### 2. ParNew收集器（JDK7之前，HotSpot服务端的新生代收集器）

是Serial收集器的多线程并行版本。

也需要暂停、采用的回收策略、对象分配规则都是一致的。

在多核的情况下，相对于Serial收集器来说能够更充分的利用资源，效率更高。并且它实现了并发垃圾收集的线程数的可配置。

目前是合并入CMS，并退出历史舞台了。

### 3. Parallel Scavenge收集器

Parallel Scavenge收集器相较于PraNew收集器更关注可控制的吞吐量。而其他的eg：CMS都是关注缩短垃圾收集时的用户等待时间。

吞吐量：用户程序的运行时间 和 处理器总消耗时间的比值。

Parallel Scavenge通过自适应调节策略提高系统吞吐量，提供了三个参数用于调节、控制垃圾回收的停顿时间及吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数，控制吞吐量大小的-XX:GCTimeRatio参数和控制自适应调节策略开启与否的UseAdaptiveSizePolicy参数。

### 4. Serial Old收集器

是Serial收集器的老年版本，主要区别是：垃圾收集算法是标记-整理算法。

### 5. Parallel Old收集器

Serial Old的多线程并行版本。

Parallel Old垃圾收集器在设计上优先考虑系统吞吐量，其次考虑停顿时间等因素，如果系统对吞吐量的要求较高，则可以优先考虑新生代的Parallel Scavenge垃圾收集器和老年代的Parallel Old垃圾收集器的配合使用。

### 6. CMS垃圾收集器

主要目的：获得最短的垃圾回收停顿时间。基于多线程的==**标记清除算法**==实现，以便在多线程并发环境下以最短的垃圾收集停顿时间提高系统的稳定性。

标记过程：

1. 初始标记：只标记和GC Roots**直接关联的对象**，速度很快，**需要暂停所有工作线程**
2. 并发标记：和用户线程一起工作，执行GC Roots跟踪标记过程，不需要暂停工作线程
3. 重新标记：在并发标记过程中用户线程继续运行，导致在垃圾回收过程中部分对象的状态发生变化，为了确保这部分对象的状态正确性，需要对其重新标记**并暂停工作线程**
4. 并发清除：和用户线程一起工作，执行清除GC Roots不可达对象的任务，不需要暂停工作线程。

——并发收集低停顿

缺点：

1. 对处理器资源敏感：虽然并发了，但是还是需要占用部分线程去执行——会占用CPU的计算能力，降低总吞吐量
2. 无法处理浮动垃圾：浮动垃圾就是在并发标记和并发清理阶段产生的新的垃圾，由于无法对其进行处理，所以只能下次GC再清理。且由于清除时是并发执行的，所以还是要有足够的内存给用户线程的。
3. ==标记清除算法会存在大量的内碎片，所以可能会触发full GC==，这个耗时就更久了