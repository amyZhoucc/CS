# JVM速成

# JVM的内存区域

JVM的位置：JVM运行在操作系统之上，不与硬件设备直接交互。对于操作系统来说JVM是应用程序。

JVM就是Java虚拟机，能够识别.class后缀的文件，然后对里面的指令进行解析，然后生成操作系统上的

需要记住的是：Java的运行时数据区包括：**方法区、堆、虚拟机栈、本地方法栈、程序计数器。——5部分**

方法区、堆：线程共享的；虚拟机栈、本地方法栈、程序计数器：线程独有的

<img src="pic\image-20210514102237803.png" alt="image-20210514102237803" style="zoom:67%;" />

直接内存也叫作堆外内存，它并不是JVM运行时数据区的一部分，但在并发编程中被频繁使用

## 内存区域的分类

### 1. pc（私有）

生命周期和线程一样

实际上就是一个字长的单位（未确定？？？）

**当前线程所在执行的字节码的行号指示器**，即：当前运行到的位置（类似于CPU的pc指针）

**字节码解释器**就是通过改变该pc值来获取下一条字节码指令。分支、跳转、循环、异常处理、线程恢复都是通过该pc完成的。

pc存在的原因：JVM是多线程切换执行的，所以要能够切换到一个线程再切换回来，需要能够回到上次的执行位置，所以需要**独立存储一个pc值**——每个线程的pc值独立存储，互不影响

- 如果线程正在执行的是Java方法，那么pc指向的是JVM的字节码指令地址；——所以pc就只是指示Java程序的执行位置

- 如果正在执行native方法，那么pc为空（undefined）

  （native方法：原生函数，就是用c/c++实现，并被编译成DLL，然后Java能够进行调用）

程序计数器区域：是唯一一个在JVM中没有规定任何`OutOfMemoryError`（内存溢出错误）的区域——因为有且只有一个字段且只改变里面的值，不存在溢出

# 垃圾回收（面试高频）

垃圾回收需要考虑的：

1. 哪些内存需要回收
2. 什么时候回收
3. 如何回收

对于线程私有的：虚拟机栈、本地方法栈、程序计数器会随着线程的消亡而消亡，分配和回收有确定性，方法结束or线程结束时，内存就一起回收了。——线程私有的内存区域不需要关注垃圾回收。

对堆的回收：堆中存放的是对象，所以对堆回收，需要知道的是**哪些对象已经死亡、哪些还存活**。——这个是GC的研究重点

## 4种引用类型

背景：JDK1.2之前，都是只有2种引用：引用 or 不引用

后面进行了4类扩展：

1. 强引用：最常见的赋值语句就是强引用，eg：`Object obj = new Object();`，只要这个引用关系还存在，那么GC就永远不会进行回收

2. 软引用：非必须，但是还有用的。

   只有在系统即将发生OOM异常时，才会将这些内存区域划入回收范围内进行二次回收。这次回收经过之后，还是OOM，那么才抛出内存溢出异常

3. 弱引用：非必须对象，只能生存到下一次垃圾收集发生为止。当前内存足够，也会对弱引用的对象进行回收

4. 虚引用：即使有虚引用，也不会影响其生存时间

## 对象的回收机制

### 1. 引用计数算法

对每个对象都增加一个字段：引用计数器，每当有一个地方引用，那么计数++；如果引用失效了，那么计数--。那么引用减少到0就意味着该对象不可能再被利用了。

优势：简单、判定效率高。

但是：主流虚拟机都不采用，因为：**需要大量的额外处理才能保证正确地工作，且存在循环引用的问题**。

eg：`objA.instance=objB; objB.instance=objA;`那么objA和objB存在互相引用，引用计数均不为0。如果此时仅有对方还在引用，其他均没有引用，那么实际上两个对象均可以被回收了，但是由于计数不为0，所以还不能回收。

### 2. 可达性分析算法（主流使用）

从**GC Root**的根对象作为起始结点开始搜索，根据引用关系向下搜索，然后走过的路径就是**引用链**

如果某个对象到GC Root之间没有任何引用链相连，那么被认为该对象不可达，就可以进行回收了。

——所以即使循环引用，只要和GC Root不相连，那么就认为这几个对象不可达。

GC Roots的对象包括以下几种：

1. 虚拟机栈（栈帧中的本地变量表）中引用的对象，eg：局部变量、参数、临时变量等
2. 在方法区中类静态属性引用的对象，eg：引用类型的静态变量
3. 在方法区中常量引用的对象，eg：常量池的引用
4. 在本地方法栈中Native方法引用的对象
5. 被同步锁synchronized持有的对象
6. JVM内部的引用，eg：基本数据类型对应的Class对象、常驻的异常对象NullPointException等，类加载器

### 3. 对象的自我拯救

如果在可达性分析中被判断为不可达，不会马上被回收，还有被救的机会。——有两次标记机会：

1. 第一次可达性分析后，发现该对象没有和GC Root存在引用链，那么**会被第一次标记**

   然后进行第二次筛选，判断该对象是否有必要执行finalized()方法（有再给一次机会的意思）

   如果没有覆盖finalized()方法（没有想自救），或者该方法已经被JVM执行过了（已经自救过一次了）

   如果没有必要执行（即上面的两种情况），那么没有必要进行二次标记，可以直接进入等待回收状态

   如果有必要执行，那么会将对象放在一个**F-Queue队列中**，然后虚拟机会创建一个低优先级Finalizer线程去执行finalize方法——只能说触发启动，但是不能保证结束（因为执行时间未知，所以不会等待其长时间的执行）

2. 在执行finalize之后，会进行对F-Queue对象进行第二次小规模标记，如果对象在finalize中拯救自己——即，重新和引用链上的任何一个对象建立联系，那么第二次标记的时候就不会再被标记，那么就能逃脱，否则就是要被回收了

——那么如果靠finalize方法进行逃逸后，再次面临回收时，finalize方法不会被再次执行，就无法再次拯救了。

——**但是不建议通过finalize方法进行拯救，因为存在大量的不确定性、代价高、 也无法保证对象的调用顺序等，所以不建议**

所以，finalize能做的（关闭资源）的清理工作，可以由**try-finally**去完成。

## 垃圾收集算法

都是属于追踪式垃圾收集算法。

### 1. 理论：3个

分代收集，即对不同的对象分为不同的分代，按照不同的机制进行回收

有2个分代假说：

1. **弱分代假说：大部分对象都是朝生夕死的**

2. **强分代假说：熬过越多次的垃圾回收，对象就越难消亡**

3. **跨代引用假说：跨代引用相对于同代引用来说仅占小部分**

   合理性：如果跨代之间存在引用，eg：新生代引用老年代，那么由于老年代难以消亡，那么新生代也会逐渐变成老年代，也就不存在跨代的问题了

   操作：不需要遍历所有老年代，只需要标记老年代的哪些区域会存在跨代引用，然后每次Minor GC时，只会那一小部分的老年代区域会被加入到扫描中。

最少：会将Java堆分为**新生代、老年代**，新生代中每次都有大量的对象死去，然后每次都存活的少量的对象就会晋升到老年代中。

### 2. 标记-清除算法（原始）

先标记要被回收的对象，然后对这些内存区域进行GC

缺点：

1. 效率未知，如果区域中大部分都需要删除，那么需要大量的标记和删除
2. 内存内碎片，由于清除的位置不确定，所以删除的位置不一定是连续的，可能会造成大量的碎片问题，导致内存分配失败

### 3. 标记-复制算法（在Minor GC中优先采用）

半区域复制。

将内存区域对半分，每次只能使用一半的内存区域。

**当这一块的内存区域用完了**，然后将该区域还存活的对象复制到另外一块上，然后将该块内存区域全部清除

所以，如果大部是存活，那么需要大量的移动；而根据弱分代假说，需要移动的会比较少，且不存在内碎片的情况。

缺点：

1. 可用内存减少了一半，空间浪费大

改进：根据98%策略

1. 将新生代区分为Eden和两块Survivor区，分别是8:1:1
2. 每次使用都是一块Eden和一块Survivor区，然后GC时将这两块的存活对象直接复制到另一块Survivor中——所以只有10%的内存区域被浪费了
3. 但是，还是存在一块Survivor不够用的情况，那么一般由老年代进行分配担保，**将这些内存对象直接进入到老年代**

——如果新生代年龄到达15后，就会被移动到老年代。

### 4. 标记-整理算法（针对Major GC，HotSpot选择）

让存活的对象都直接向内存空间的一端移动，然后直接清除掉边界外面的内存——移动的，而原始的标记-清除算法是不移动的

存在问题：根据强分代假说，每次有大量的对象存活，移动耗时很大，且必须要暂停用户应用程序才能进行

——但是这样的代价，能够减少碎片（这个会更加影响**系统吞吐量**），所以移动对象更划算

和稀泥方法：平时采用标记-清除算法，直到碎片情况已经影响到内存分配了，那么才会调用标记-整理算法一次，然后又有多余的内存空间了

——CMS收集器就是采用这种方法的

## 经典垃圾收集器

首先明确：没有最好的垃圾收集器，也不会存在万能的垃圾收集器。只有对应于某个具体应用最合适的收集器。

### 1. Serial收集器（HotSpot客户端默认的新生代收集器）

最基础。

**单线程工作的收集器：只会使用一个处理器去完成，且在执行的时候需要暂停其他线程的工作，直到收集结束。**

优点：

1. 简单、高效
2. 对于资源受限的环境，是所有收集器中额外开销最小的
3. 单线程收集效率最高

缺点：需要暂停其他工作线程

### 2. ParNew收集器（JDK7之前，HotSpot服务端的新生代收集器）

是Serial收集器的多线程并行版本。

也需要暂停、采用的回收策略、对象分配规则都是一致的。

在多核的情况下，相对于Serial收集器来说能够更充分的利用资源，效率更高。并且它实现了并发垃圾收集的线程数的可配置。

目前是合并入CMS，并退出历史舞台了。

### 3. Parallel Scavenge收集器

Parallel Scavenge收集器相较于PraNew收集器更关注可控制的吞吐量。而其他的eg：CMS都是关注缩短垃圾收集时的用户等待时间。

吞吐量：用户程序的运行时间 和 处理器总消耗时间的比值。

Parallel Scavenge通过自适应调节策略提高系统吞吐量，提供了三个参数用于调节、控制垃圾回收的停顿时间及吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数，控制吞吐量大小的-XX:GCTimeRatio参数和控制自适应调节策略开启与否的UseAdaptiveSizePolicy参数。

### 4. Serial Old收集器

是Serial收集器的老年版本，主要区别是：垃圾收集算法是标记-整理算法。

### 5. Parallel Old收集器

Serial Old的多线程并行版本。

Parallel Old垃圾收集器在设计上优先考虑系统吞吐量，其次考虑停顿时间等因素，如果系统对吞吐量的要求较高，则可以优先考虑新生代的Parallel Scavenge垃圾收集器和老年代的Parallel Old垃圾收集器的配合使用。

### 6. CMS垃圾收集器

主要目的：获得最短的垃圾回收停顿时间。