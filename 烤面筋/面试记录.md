# 面试记录

## 1. b站1面

总体的：面试官问的很基础，也问的挺好的，就是我太菜了，没有好好准备:weary:

> Java的内存模型

堆栈、堆、方法区

字符串存放的位置、数组的存放位置：在堆中

> Java中的基本类型和类类型的区别

从存储来说，基本数据类型就是其本身，存放的位置在栈中，类类型创建的对象是存放在堆中，对它的引用变量会存放在栈中。

> Java对象的clone

1. 基本数据变量的clone，就是其本身

2. 复制对象

   都是继承自：Object超类

   是native方法，且是protected修饰方法

   ```java
   protected native Object clone() throws CloneNotSupportedException;
   ```

   能够保证：

   1. 新clone的对象有一个新的地址分配
   2. 新clone的对象和原始对象有相同的类类型——不强制
   3. 调用equals方法，应该返回true

——如果需要clone，那么要重写clone方法

clone步骤：

1. 被复制的类需要实现cloneable接口，否则会抛出CloneNotSupportedException异常——这个接口是表示功能的，里面没有方法，类似于RandomAccess

2. 重写clone方法，修饰符有public修饰符

   **方法中调用super.clone()方法得到需要的复制对象**——浅拷贝

如果需要深拷贝，那么需要明确里面的有哪些是类对象，哪些是基本数据类型，对于类对象需要dfs将所有相关的类元素全部调用本身的clone方法——全部重新给一个地址

> 泛型的<? extends T>, <? super T>

extends是设定的参数的上限，即只能是T的子类

super是设定的参数T的父类，即只能是T的父类

> android的activity的生命周期、fragment的生命周期
>
> ​	没回答出来，真是该打:hankey:

1. onCreate
2. onRestart
3. onStart
4. onResume
5. onPause
6. onStop
7. onDestory

fragment：运行状态、暂停状态、停止状态和销毁状态

> listview 和recyclerview的区别
>
> list的效率问题

1. listview主要是性能优化的难题，listview的getView每次都会将布局刷新一遍，所以快速滑动会影响效果

   ——需要进行缓存：convertView()，对之前加载好的布局进行缓存

   每次需要findViewById()，可以用view.tag进行绑定

   但是扩展性不好：只能实现纵向移动效果，而不能实现横向移动

   listview只能setOnItemClickListener()方法注册的是子项的点击事件——而对item里面的某一个进行点击无法做到

2. recyclerview需要添加依赖，能够进行扩展：横向移动、瀑布流布局

   并且itemDecoration可以修改里面的item进行布局

   且灵活性更高

> android的序列化

可以将对象转化成可以用来存储和传输的形式，这个过程就是序列化

1. serializable
2. parcelable

> android的handler了解吗



> webview对url的拦截



> GIT的提交
>
> GIT branch需要的注意事项



