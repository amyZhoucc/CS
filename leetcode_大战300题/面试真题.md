# 面试真题

## 百度

没有找到类似的原题，面试的时候数次看错题目，太尴尬了:sweat:

> 字符串模式匹配
>
> 1. 模式匹配定义：某个长度为3的子串满足：第一个字母和第三个字母一样，且和第二个字母不一样，就认为是匹配的
> 2. 给一个任意长度的字符串，要求输出最后不满足上面模式的子串
>
> eg: 满足要求的子串：aba，xyx，不满足要求的123，122
>
> 输入：abxyxc，输出：abc——去掉满足要求的
>
> 输入：dabxyxac，输出：dc

我的策略：（存在问题）

遍历字符串，找到第一个匹配的子串，然后以该子串的第一个字母为left，第三个字母为right，开始扩展遍历（为防止重复遍历，会有变量back，记录上一次的right，以back为界left不能超过）

因为按照`abxyxa`，这个情况来说是：`left-2,left-1, right+1`/ `left-1, right-1, right-2`，只有这两种情况需要考虑，即

1. `left-2==right+1 && left-2!=left-1`——满足要求，在中间删除后，它也会被删除

2. `left-1==right+2 && right+1!=right+2`——满足要求

3. 其余情况均不满足，且扩展遍历终止

   记录下一些信息：

   - 这部分的删除范围[left,right]——闭区间，存放到一个列表里面
   - 更新back，back=right，下一次遍历的left不能超过back，因为back之前的已经遍历过了

当字符串遍历结束后，取出所有的删除闭区间，创建stringbuilder将不需要删除的区间全部取出来构建新的字符串

```java
import java.util.*;

public class Main {
    private static String stringPattern(String s) {
        int len = s.length();
        if (len < 3) return s;
        int left = 0;
        ArrayList<int[]> storeDelete = new ArrayList<>();       // 待删除坐标记录
        int back = -1;				// 边界记录，上一次删除范围的right，此次遍历的left不能超过back
        while (left < len - 2) {		// 字符串遍历
            // 找到第一个匹配的了
            if ((s.charAt(left + 1) != s.charAt(left)) && (s.charAt(left) == s.charAt(left + 2))) {
                int l = left, r = left + 2;                 // 初始的待删除范围[]
                // 存在left的前一个字母，和right的后一个字母，且left没有超范围（上一次的right范围）
                while (l >= 0 && r < len && back < l) {           
                    // l-2的字母存在 / r + 2的字母存在
                    if (back < l - 2 && l - 2 >= 0 && r + 1 < len && (s.charAt(l - 1) != s.charAt(l - 2) && s.charAt(r + 1) == s.charAt(l - 2))) {
                        l -= 2;
                        r += 1;
                    } else if (back < l - 1 && l - 1 >= 0 && r + 2 < len && (s.charAt(r + 1) != s.charAt(r + 2) && s.charAt(r + 2) == s.charAt(l - 1))) {
                        l -= 1;
                        r += 2;
                    } else {		// 不满足，就说明扩展循环结束
                        storeDelete.add(new int[]{l, r});			// 保存删除的范围[]
                        back = l;			// 更新back
                        break;                  // 结束循环
                    }
                }
                left = r;			// 因为存在扩展，所以需要更新left
            }
            left++;
        }
        StringBuilder sb = new StringBuilder();
        int cur = 0;
        for (int i = 0; i < storeDelete.size(); i++) {
            sb.append(s.substring(cur, storeDelete.get(i)[0]));			// [cur, left)不需要删除的空间
            cur = storeDelete.get(i)[1] + 1; // right+1下一个不需要删除的起点（可能也要删除）[left,right]跳过
        }
        sb.append(s.substring(cur, s.length()));
        return sb.toString();
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        String s = in.nextLine();
        System.out.println(stringPattern(s));
    }
}
```

这个方法是存在问题的，目前没有办法解决最佳的删除方式问题：

eg：babxyxacb，按照首次匹配原则，bab删除（无法再扩展），xyx删除（无法再扩展），最后留下acb

如果是最优的是：以xyx为结点开始删除，扩展到：ab()a可以删除，继续扩展：b()cb可以删除，最后字符串为空

——目前还没有想到解决方法