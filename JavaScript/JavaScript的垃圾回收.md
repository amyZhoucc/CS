# GC

JavaScript的垃圾回收也是执行环境负责管理的（类似于Java，而不同于c、c++需要程序自行管理）

JavaScript的垃圾回收是周期性发生的，每隔一定的时间（触发某个预定的阈值）就会自动进行GC

## 标记清理

JavaScript中最常用的GC方法

操作流程：当变量进入上下文，例如函数中创建了一个局部变量，那么该变量就会加上**存在于上下文的标记**——那么该变量永远不会被回收；当离开上下文，会加上**离开上下文的标记**。在GC运行时，先标记内存中的所有变量，然后将**在上下文的变量**（通过上下文标记）和**被上下文引用的变量**（通过引用链，类似于JavaGC的可达性分析）的标记去掉，其他仍被标记的就是待删除的变量，然后做一次内存清理

具体实现策略，可以用两个数组，或者标志位等

## 引用计数

存在的问题：循环引用

eg：在IE8及更早版本的IE中，并非所有对象都是原生JavaScript对象。BOM和DOM中的对象是C++实现的组件对象模型（COM, Component Object Model）对象，而COM对象使用引用计数实现垃圾回收——所以就存在循环引用无法回收的问题

——IE9把BOM和DOM对象都改成了JavaScript对象，这同时也避免了由于存在两套垃圾回收算法而导致的问题，还消除了常见的内存泄漏现象

——在一次完整的垃圾回收之后，V8的堆增长策略会根据活跃对象的数量外加一些余量来确定何时再次垃圾回收。

## 优化内存占用

分配给浏览器的内存通常比分配给桌面软件的要少很多，分配给移动浏览器的就更少了。所以要优化占用的内存比例

1. 在执行代码时只保存必要的数据，如果不再必要，可以设置为null——解除引用

   全局变量、全局对象的属性

2. const/let能够提升性能，相较于var，const/let作用域都是块级别的，所以GC会加快对它们的回收

3. v8会将创建的对象与隐藏类关联起来，以跟踪它们的属性特征。能够共享相同隐藏类的对象性能会更好，V8会针对这种情况进行优化，所以相同的类对象使用相同的隐藏类，但是如果他们的动态属性变化（删了一个、增了一个等）就无法共享了，就无法优化了——避免JavaScript的“先创建再补充”动态属性，在构造函数中一次性声明所有属性，不想要的设置为null（引用值也会被回收）

内存泄漏：

1. 声明变量时不带var、let、const，那么会默认为是window属性来创建，它的生命周期将很长很长，直到网页被关闭

2. 定时器的回调通过闭包引用了外部变量

   ```javascript
   setInterval(() =>{
       console.log(name);		// 上面声明并赋值过了
   })
   ```

   只要定时器一直在运行，那么name变量一直不会被回收

   ——使用JavaScript闭包很容易在不知不觉间造成内存泄漏

## 减少GC频率

浏览器决定何时运行垃圾回收程序的一个标准就是对象更替的速度

如果有很多对象被初始化，然后一下子又都超出了作用域，那么浏览器就会采用更激进的方式调度垃圾回收程序运行，这样当然会影响性能

比如函数中的局部变量在函数结束的时候就会被回收，那么可以传入一个对象类型，然后返回值作为对象的属性被设置

——更高级的：**使用对象池**。在初始化的某一时刻，可以创建一个对象池，用来管理一组可回收的对象。应用程序可以向这个对象池请求一个对象、设置其属性、使用它，然后在操作完成后再把它还给对象池

由于**JavaScript数组的大小是动态可变的**，引擎会删除不够大小的数组，再创建一个新的大一点的数组。垃圾回收程序会看到这个删除操作，说不定因此很快就会跑来收一次垃圾。要避免这种动态分配操作，可以在初始化时就创建一个大小够用的数组，从而避免上述先删除再创建的操作。





