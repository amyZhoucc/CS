# 技巧

## 1. 全局获取Context

背景：很多逻辑代码需要脱离Activity类，而单独存在，但是又需要用到**Context**，所以我们需要全局定义。

创建一个MyApplication类继承自Application

```kotlin
import android.annotation.SuppressLint
import android.app.Application
import android.content.Context

class MyApplication : Application() {
    companion object{
        @SuppressLint("StaticFieldLeak")	// as评估存在内存泄漏的隐患，但实际上不会，用此忽略
        lateinit var context: Context
    }

    override fun onCreate() {
        super.onCreate()
        context = applicationContext
    }
}
```

理解：

- 在companion object中定义了一个context变量：类似于Java的静态变量

- 重写父类的onCreate()方法：getApplicationContext()方法得到的返回值赋值给context变量

  ——getApplicationContext()：ContextWrapper.java中存在

——以静态变量的形式获取Context对象了。

但是存在：将context设置成静态变量容易产生内存泄漏的问题（因为是一个全局变量不会被回收，而如果该context如果被删除了，那么还会存在引用的问题，导致无法及时回收变量）

——由于这里获取的不是Activity或Service中的Context，而是**Application中的Context**，它全局只会存在一份实例，并且在整个应用程序的生命周期内都不会回收，因此是不存在内存泄漏风险的。

当然还需要告知系统需要进行该类的初始化，所以，需要在AndroidManifest.xml中进行修改

```
<application
    android:name=".MyApplication"		// 指定一下，本来不存在该字段
    android:allowBackup="true"
    android:icon="@mipmap/ic_launcher"
    android:label="@string/app_name"
    android:roundIcon="@mipmap/ic_launcher_round"
    android:supportsRtl="true"
    android:theme="@style/Theme.Activity">
```

## 2. 