# http的学习

官方建议使用：**HttpURLConnection**

## 1. 使用HttpURLConnection

简单步骤：

1. 创建URL对象
2. 调用openConnection()方法
3. 强制类型转换为HttpURLConnection的实例

```kotlin
val url = URL("https://baidu.com")
val connection = url.openConnection() as HttpURLConnection
```

```
connection.requestMethod = "GET"
```

还可以自定义的：设置连接超时、读取超时的毫秒数，以及服务器希望得到的一些消息头等，分别是：

调用**getInputStream()**方法就可以获取到服务器返回的输入流

```kotlin
connection.connectTimeout = 500			// 连接超时等待时间
connection.readTimeout = 800				// 读取超时等待时间
val input = connection.inputStream	// 获得相应的数据流
connection.disconnect()					// 断开连接
```

如果要提交数据：

1. 只需要将HTTP请求的方法改成POST：`connection.requestMethod = "POST"`

2. 并在获取输入流之前把要提交的数据写出即：

   ```kotlin
   val url = URL("http://www.baidu.com")
   val connection = url.openConnection() as HttpURLConnection
   connection.requestMethod = "POST"			// post的请求方式
   connection.connectTimeout = 8000
   connection.readTimeout = 8000
   val output = DataOutputStream(connection.outputStream)		// 发送数据流
   output.writeBytes("username=admin&password=123456")			// 上传
   
   val input = connection.inputStream
   ....
   ```

```kotlin
private fun sendRequestWithHttpURLConnection(){
  thread {            // 开启了一个线程，去发起网络请求
    var connection : HttpURLConnection ?= null
    try {
      val response = StringBuilder()
      val url = URL("http://www.baidu.com")
      val connection = url.openConnection() as HttpURLConnection
      connection.requestMethod = "POST"
      connection.connectTimeout = 8000
      connection.readTimeout = 8000
      val input = connection.inputStream      // 获得响应
      val reader = BufferedReader(InputStreamReader(input))       // 处理输入流，是Java中的标准写法
      reader.use {
        reader.forEachLine { response.append(it) }
      }
      show(response.toString())
    }catch (e: Exception){
      e.printStackTrace()
    }finally {
      connection?.disconnect()
    }
  }
}

private fun show(response : String){
  runOnUiThread {
    binding.responseText.text = response
  }
}
```

## 2. OkHttp

首选的网络通信库。OkHttp在接口封装上做的很简单。

当然需要导包：

```
implementation 'com.squareup.okhttp3:okhttp:4.1.0'
```

然后也需要开权限。

1. 先开一个okhttpclient实例

   ```kotlin
   val client = OkHttpClient()
   ```

2. 发起请求，需要创建Request对象

   ```
   val request = Request.Builder().url("https://www.baidu.com").build()
   ```

   可以在builder和build之间添加需要传递的字段，eg：url

3. 发起请求并返回数据

   ```kotlin
   val response = client.newCall(request).execute()
   ```

4. 整理数据：

   ```kotlin
   val responseData = response.body?.string()
   ```

如果是post请求

需要构建一个RequestBody对象来存放待提交的参数。

```kotlin
val requestBody = FormBody.Builder().add("username", "admin").add("password", "1234").build()
```

```kotlin
val request = Request.Builder().url("https://www.baidu.com").post(requestBody).build()
```

```kotlin
private fun sendRequestWithOkHttp(){
        thread {
            try {
                val client = OkHttpClient()
                val requestBody = FormBody.Builder().add("username", "admin").add("password", "1234").build()
                val request = Request.Builder().url("https://www.baidu.com").post(requestBody).build()
                val response = client.newCall(request).execute()
                val responseData = response.body?.string()
                if(responseData != null){
                    show(responseData)
                }
            }catch (e : Exception){
                e.printStackTrace()
            }
        }
    }

private fun show(response : String){
  runOnUiThread {
    binding.responseText.text = response
  }
}
```

## 3. Json格式解析

刚才我们取出的数据是直接将其转换成了string，然后直接打印出来的，具体里面的内容都不关注的。

但是在实际中，每个相应的内容都具有一定的格式，所以我们要将其进行解析

常见的格式有：xml、json

JSON的主要优势在于它的体积更小，在网络上传输的时候更省流量。但缺点在于，它的语义性较差，看起来不如XML直观。

格式：

```json
[{"id":"5","version":"5.5","name":"Clash of Clans"}, 
 {"id":"6","version":"7.0","name":"Boom Beach"}, 
 {"id":"7","version":"3.5","name":"Clash Royale"}]
```

解析JSON数据也有很多种方法，可以使用官方提供的**JSONObject**，也可以使用Google的开源库**GSON**

### 3.1 JSONObject

```kotlin
private fun parseJSONWithJSONObject(jsondata : String){
        try {
            val jsonArray = JSONArray(jsondata)         // 由于定义的是数组，所以将string转换为数组格式
            for (i in 0 until jsonArray.length()){          // 遍历数组
                val jsonObject = jsonArray.getJSONObject(i)     // 每个元素都是一个json对象
                val id = jsonObject.getString("id")
                val version = jsonObject.getString("version")
                val name = jsonObject.getString("name")
            }
        }catch (e : Exception){
            e.printStackTrace()
        }
    }
```

理解：解析的步骤：

1. 将string对象转换成array： JSONArray(data)，里面的每个元素都是jsonobject对象
2. 开始遍历数组，for(i in 0 until array.length())
3. 获得每个对象：array.getJSONObject()
4. 然后取出里面的字段：objet.getString("xxx")

### 3.2 GSON

需要添加依赖库

```
implementation 'com.google.code.gson:gson:2.8.5'
```

步骤：

1. 创建gson对象

   ```
   val gson = Gson()
   ```

2. 获得对象

   ```kotlin
   val app = gson.fromJson(data, App::class.java)			// 然后就能获得指定的对象了
   ```

如果传递的数据是一个数组的话，需要进行转换：

借助TypeToken将期望解析成的数据类型传入fromJson()方法

具体实现：

```kotlin
private fun parseJSONWithGSON(jsondata: String){
  val gson = Gson()			// 创建一个gson对象
  val typeOf = object:TypeToken<List<App>>(){}.type
  val appList = gson.fromJson<List<App>>(jsondata, typeOf)
  for(app in appList){
    Log.d("mainactivity", "id is ${app.id}")
    Log.d("mainActivity" , "name is ${app.name}")
    Log.d("mainActivity", "version is ${app.version}")
  }
}
```

## 4. xml解析

暂放

## 5. 请求回调

背景：很多地方需要请求网络，所以要将请求的内容进行封装，然后统一调用该方法`sendHttpRequest`即可，但是这个是耗时操作，如果是主线程执行则会被阻塞，所以**需要开启子线程去执行** ，但是存在的问题是：sendHttpRequest()方法会在服务器还没来得及响应的时候就执行结束了，当然也就无法返回响应的数据

——使用回调机制。

主要结构就是：

1. 封装一个请求的单例类，里面实现请求方法

   传递的参数：地址、回调函数

   ```kotlin
   object HttpUtil {
     fun  sendHttpRequest(address : String, listener: HttpCallbackListener){
   			// 添加具体的请求网络逻辑
     }
     fun sendOkHttpRequest(address : String, callbackListener: okhttp3.Callback){
   
     }
   ```

   理解：

   具体实现里面类似上面的请求，需要开启子线程去实现：

   ```kotlin
   thread {            // 开启了一个线程，去发起网络请求
     var connection : HttpURLConnection?= null
     try {
       val response = StringBuilder()
       val url = URL("http://www.baidu.com")
       val connection = url.openConnection() as HttpURLConnection
       connection.requestMethod = "POST"
       connection.connectTimeout = 8000
       connection.readTimeout = 8000
       val input = connection.inputStream      // 获得响应
       val reader = BufferedReader(InputStreamReader(input))       // 处理输入流，是Java中的标准写法
       reader.use {
         reader.forEachLine { response.append(it) }
       }
       listener.onFinish(response.toString())			// 回调函数
     }catch (e: Exception){
       listener.onError(e)			// 回调函数
     }finally {
       connection?.disconnect()
     }
   }
   ```

2. 创建一个接口，定义回调函数：

   ```kotlin
   interface HttpCallbackListener {
       fun onFinish(response : String)         // 成功响应之后调用
       fun onError(e: Exception)           // 出现错误时调用
   }
   ```

3. 使用

   在通过httputil方法进行请求的时候，需要传递的是address，且还需要传递接口的实例对象，所以需要将上面的两个方法实现——看具体需要

   ```kotlin
   private fun sendRequestWithHttpURLConnection(){
     HttpUtil.sendHttpRequest("https://www.baidu.com", object : HttpCallbackListener{
       override fun onFinish(response: String) {
         TODO("Not yet implemented")
       }
   
       override fun onError(e: Exception) {
         TODO("Not yet implemented")
       }
     })
   }
   ```

——所以通过HttpCallbackListener里面的回调函数，实现了将响应数据返回给调用方

而okhttp对该实现很方便：

不需要自行写回调函数，直接使用内部的callback函数即可：

```kotlin
object HttpUtil {
  fun sendOkHttpRequest(address : String, callbackListener: 				 okhttp3.Callback){				// 这边的callback是okhttp3自带的，和上面自定义的类似，也是一个接口，也有两个方法需要实现
    val client = OkHttpClient()
    val request = Request.Builder().url(address).build()		//同上
    client.newCall(request).enqueue(callbackListener)		// 存在区别
  }
}
```

理解：调用的**enqueue**方法，内部能自动开启子线程，然后在里面执行请求

需要传递的参数：callbackListener——回调函数即可

```kotlin
private fun sendRequestWithOkHttp(){
  HttpUtil.sendOkHttpRequest("https://www.baidu.com", object: Callback{
    override fun onResponse(call: Call, response: Response) {
      TODO("Not yet implemented")
    }

    override fun onFailure(call: Call, e: IOException) {
      TODO("Not yet implemented")
    }
  })
}
```

## 5. retrofit

OkHttp侧重的是底层通信的实现，而Retrofit侧重的是上层接口的封装

基本用法：配置好一个根路径，然后在指定服务器接口地址时只需要使用相对路径。

可以将对服务器接口进行归类，将功能同属一类的服务器接口定义到同一个接口文件当中。

需要添加依赖：

```
//retrofit网络库的使用（默认会下载okhttp3，所以不需要上面的语句，也会下载gson）
implementation 'com.squareup.retrofit2:retrofit:2.6.1'
implementation 'com.squareup.retrofit2:converter-gson:2.6.1'
```

使用：

1. 首先还是需要定义json数据的格式：

```kotlin
data class App(val id : String, val version : String, val name : String)
```

2. 设定服务：这边命名按照xxxService来

   按照任务分类来，就是写一个抽象接口，用来发起请求等

   ```kotlin
   // 接口文件建议以具体的功能种类名开头，并以Service结尾
   interface AppService {
   
       // getAppData()方法时Retrofit会发起一条GET请求，请求的地址就是我们在@GET注解中传入的具体参数——这边是相对路径，根路径在其他地方会设定
       @GET("get_data.json")
       fun getAppData() : Call<List<App>>
   }
   ```

3. 实现使用

   核心：

   1. `val retrofit = Retrofit.Builder().baseUrl("https://www.baidu.com").addConverterFactory(GsonConverterFactory.create()).build()`

      创建retrofit对象，需要指定根路径baseurl，指定Retrofit在解析数据时所使用的转换库addConverterFactory，这边就是选择gson

   2. 调用retrofit的create方法

      创建对应接口的动态代理对象——那么就可以**随便使用该接口里面的方法了**

   3. 调用接口方法，会返回一个Call<List<App>>对象，这时我们再调用一下它的enqueue()方法——那么去请求服务器了

   4. enqueue里面还是需要传递一个callback对象的，然后就要重写的里面的两个方法

   ```kotlin
   binding.get.setOnClickListener{
     // 创建一个retrofit对象
     val retrofit = Retrofit.Builder().baseUrl("https://www.baidu.com").addConverterFactory(GsonConverterFactory.create()).build()
     // 调用create方法，创建该接口的动态代理对象——能够调用接口中的方法了
     val appService = retrofit.create(AppService::class.java)
     appService.getAppData().enqueue(object : retrofit2.Callback<List<App>>{
       override fun onResponse(
         call: retrofit2.Call<List<App>>,
         response: retrofit2.Response<List<App>>			// 这个就是响应的值
       ) {
         val list = response.body()			// 获得里面的内容
         if(list != null){
           for(app in list){
             ...
           }
         }
       }
   
       override fun onFailure(call: retrofit2.Call<List<App>>, t: Throwable) {
         TODO("Not yet implemented")
       }
     })
   ```

处理复杂的请求：

前面的请求比较简单：baseurl + 确定的相对路径

但是，如果需要传递一定的参数

eg：`https://www.baidu.com/<page>/get_data.json`

而page是可变的，那么需要在getData方法中增加参数：

```kotlin
@GET("{page}/get_data.json")			// 带上一个占位符{}
fun getPageAppData(@Path("page") page : Int) : Call<App>			// 针对该占位符,需要对应传参，使用@Path("page")注解来声明这个参数
```

而如果传递的数据需要的带上参数，类似于键值对的形式，那么可以用Query来实现：

```kotlin
@GET("get_data.json")
fun getMultiAppData(@Query("u") user: String, @Query("t") token : String) : Call<App>
```

请求的方式也可以多样：

使用@GET、@POST、@PUT、@PATCH、@DELETE注解

如果要使用post上传数据，那么可以使用：

```
@POST("/xxx")
fun createData(@Boyd data : Data) : Call<ResponseBody>
```

加上了**@Body注解**。这样当Retrofit发出POST请求时，就会自动将**Data对象中的数据转换成JSON格式的文本**，并放到HTTP请求的body部分。

——其他的也都类似。

有些服务器接口还可能会要求我们在HTTP请求的**header中指定参数**

eg：

<img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20210616141757771.png" alt="image-20210616141757771" style="zoom:80%;" />

直接使用@Headers注解来对它们进行声明：

静态的方式：

<img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20210616141858263.png" alt="image-20210616141858263" style="zoom:67%;" />

动态的方式：

<img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20210616141942136.png" alt="image-20210616141942136" style="zoom:67%;" />

背景：获取Service接口的动态代理对象实在是太麻烦，如果有多个地方要进行网络请求，可以封装成一个类进行调用。

主要思想：构建出的Retrofit对象是**全局通用**的，只需要在调用create()方法时针对不同的Service接口传入相应的Class类型即可

```

```

