# Android的IPC

在Android里面主线程也叫UI线程，在UI线程里才能操作界面元素。而其他耗时的操作都必须放在子线程中执行，

Android虽然搭载在Linux上面，但是有自己的进程间通信方式。**在Android中最有特色的进程间通信方式就是Binder**

Android使用多进程的原因：

1. 因为自身原因，需要开启多进程

2. 不同应用之间进行通信，从而获取数据

   eg：系统提供的ContentProvider去查询数据的时候，其实也是一种进程间通信

## 1. Android的多进程

### 1.1 开启多进程

通过给**四大组件指定android:process属性**，我们可以开启多进程模式。

注意：只有4大组件，才配开启多进程，在`AndroidManifest.xml`中对注册的组件进行配置

ps：还有另一种非常规的多进程方法，那就是通过JNI在native层去fork一个新的进程

没有为它指定process属性，那么它运行在**默认进程**中，默认进程的**进程名是包名**。

声明方式：

```xml
<activity
	...
	android:process=":remote"/>
	
<activity
	...
	android:process="com.zcc.chapter2.remote"/>
```

第一种类似于：相对引用，“:”的含义是指要在当前的进程名前面附加上**当前的包名**，这是一种简写的方法

且它属于**私有进程**，其他应用的组件不可以和它跑在同一个进程中

第二种类似于：绝对引用

属于**全局进程**，通过ShareUID方式可以和它跑在同一个进程中——要求是这两个应用有**相同的ShareUID并且签名相同**才可以（这样的两个应用可以共享：对方的私有数据，比如data目录、组件信息等）。如果在同一个进程，那么还能共享内存数据。

### 1.2 多进程的运行模式

Android为每个进程都分配一个独立的虚拟机，则内存地址是不同的。所以他们之间的数据是存在隔离的。

运行在不同进程中的四大组件，只要它们之间需要**通过内存来共享数据，都会共享失败**，这也是多进程所带来的主要影响——所以必须要使用IPC才能实现。

使用多进程会造成如下几方面的问题：

1. 静态成员和单例模式完全失效。

   不同的虚拟机访问同一个类的对象会产生多份副本

2. 线程同步机制完全失效

   不属于同一个进程，那么锁、同步机制都无效了

3. SharedPreferences的可靠性下降

   SharedPreferences底层是通过读/写XML文件来实现的，并发问题是很显然的

4. Application会多次创建

   不同虚拟机实际上就是将一个应用又启动了一次。

所以，数据传递不能用共享内存的模式了，而是必须通过数据传递，eg：

1. Intent来传递数据
2. 共享文件和SharedPreferences
3. 基于Binder的Messenger和AIDL以及Socket

## 2. Android的IPC基础

### 2.1 Serializable接口

Java所提供的一个序列化接口，需要自行实现，那么该对象能够实现序列化和反序列化的操作。

实现的方法简单：

```kotlin
private val serialVersionUID = 1L
```

即可自动实现默认的序列化过程，但是serialVersionUID也不是必需的，可以实现序列化，但是这将会对反序列化过程产生影响。

系统可以自行实现里面的序列化和反序列化逻辑。

```

```



### 2.2 Parcelable接口

### 2.3 Binder