# HTTP的一些补充

## HTTP/1.1的优化

3种优化思路：

1. 减少发送HTTP请求——本地缓存
2. 需要发送HTTP请求，但是减少请求次数——减少重定向次数；合并请求；延迟请求
3. 减少服务端的响应次数——压缩

### 减少HTTP请求

==对于重复的HTTP请求，可以在本地保存【请求-响应】对，然后下次遇到同样的请求，可以先查看是否有==**本地缓存**，如果有就可以避免重复请求。

但是，存在缓存一致性问题——缓存过期了？

——服务器在响应的时候，会估算一个**存活时间**，放在响应首部一起传送过去。如果客户端保存缓存的时候，发现已经过期了，就会重新发送请求，该请求会带上**Etag**，是包含了上次请求的摘要用来唯一标志响应内容的，服务端会将摘要和当前内容进行比较，如果发现没有更新，那么使用304；如果有更新，就带上最新资源

### 减少请求次数

#### 减少重定向次数

301、302响应内容的location会带上新URL，浏览器会自动访问该URL，那么本次请求需要发起两次HTTP请求——降低网络性能。

但是，如果重定向由代理服务器完成，本机并不知道发生重定向，那么能减少HTTP请求。——并且当代理服务器知道重定向规则后，可以减少消息传递的次数。

eg：301、308会让客户端将重定向的URL缓存下来。

#### 合并请求

访问多个小文件的请求，可以**合并为访问一个大文件**。那么总资源一样，HTTP的头部减少了

eg：网页包含很多个小图片，可以将这些图片使用`CSS Image Sprites`技术把它们合成合成一个大图片，然后在显示的时候再进行划分

eg：服务端用webpack等打包工具将js、css资源进行打包然后传送过去

但是存在的问题：如果某个小资源发生更新，那么需要重新下载整个大资源。

#### 延迟发送请求

按需获取。不会马上加载整个页面资源，而是当需要的时候才下载。

eg：在浏览页面的时候，只有到了当前页面，才加载当前页面的内容

### 减少响应的数据大小

无损压缩：信息不破坏，解压之后还是一样的。eg：文本文件、exe文件、程序源代码

eg：gzip

有损压缩：解压的数据相近，但不完全一样。eg：多媒体文件，图片、视频等

eg：WebP

## CA证书

存在一个证书链，实际上证书一般不是根证书签发的，而是中间证书签发的

对于这种三级层级关系的证书的验证过程如下：

1. 客户端收到 baidu.com 的证书后，发现这个证书的签发者不是根证书，就⽆法根据**本地已有的根证书**中的公钥去验证 baidu.com 证书是否可信。于是，客户端根据 baidu.com 证书中的签发者，找到该证书的颁发机构是 “GlobalSign Organization Validation CA - SHA256 - G2”，然后**向 CA 请求该中间证书**。
2. 请求到证书后发现 “GlobalSign Organization Validation CA - SHA256 - G2” 证书是由 “GlobalSign Root CA” 签发的，由于 “GlobalSign Root CA” 没有再上级签发机构，说明它是根证书，也就是⾃签证书。应⽤软件会检查此证书有否已预载于根证书清单上，如果有，则可以利⽤**根证书中的公钥去验证 “GlobalSign Organization Validation CA - SHA256 - G2” 证书**，如果发现验证通过，就认为该中间证书是可信的。
3. “GlobalSign Organization Validation CA - SHA256 - G2” 证书被信任后，可以使⽤ “GlobalSign Organization Validation CA - SHA256 - G2” 证书中的公钥去验证 baidu.com 证书的可信性，如果验证通过，就可以信任baidu.com 证书。

——递归回溯的思路：通过当前证书获取到中间证书，向上直到根证书，然后通过根证书的公钥去向下验证中间证书，验证通过说明该中间证书可信，然后通过中间证书的公钥去解密下一层的证书，直到最下层的当前证书验证通过。

<img src="pic\image-20210419113920801.png" alt="image-20210419113920801"  />

## RSA的问题：

不支持前向保密，即对称密钥是通过公钥进行加密，私钥进行解密的。如果私钥被破解，那么对称密钥也相对的被破解了。

有了DH密钥交换技术：

<img src="pic\image-20210419123635080.png" alt="image-20210419123635080" style="zoom:80%;" />

客户端和服务端都会生成一对公私密钥，然后分别交换公钥，然后根据自己的密钥和对方的公钥利用公开算法计算出对应的密钥，然后在后面都是用该密钥进行加密的。——密钥值是一样的，所以后续还是对称加密。由于每一次的对称密钥都是实时生成的，所以实现了前向保密。
